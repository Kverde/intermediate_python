% Intermediate Python
% Obi Ike-Nwosu
% leanpub.com, 2016

# Intermediate Python

Перевод книги [Intermediate Python](https://leanpub.com/intermediatepython) Obi Ike-Nwosu. Перевод выполнен с сокращениями, часть текста и примеры изменены.

## 1. Благодарности

Текст с благодарностями автора оригинального издания без корректировок.

I would love to take the opportunity to thank all who have reviewed and spotted issues in the manuscript. This includes but is not limited to Ngozi Nwosu for taking the time out to review the whole manual and point out a whole load of grammatical errors, Olivia Enewally, Roman Turna and Abhen Ng for pointing out some factual and grammatical errors.A whole lot of other people on Reddit have pointed out errors and to those people I am really grateful. 

Without the input of all these people, this manuscript would be worth less than it currently is. Thank you all!

## 2. Введение

Эта книга рассчитана на средний уровень знакомства с Python. В качестве интерпретатора подразумевается [CPython](https://www.python.org/). [Документация](https://docs.python.org/3/reference/index.html) последней стабильной версии.

## 3. Очень короткий учебник

Этот короткий учебник раскрывает основные концепции и возможности языка программирования Python.

### 3.1 Использование Python

Python установлен по умолчанию на Unix-системах. Для проверки установлен ли Python, откройте командную строку и введите `python`. Если Python не установлен то откройте [сайт Python](https://www.python.org/) и следуйте инструкциям для вашей платформы.

Если после установки Python не запускается из командной строки, проверьте добавлен ли путь к интерпретатору в системные пути.

Запуск интерпретатора командой `python` начинает интерактивную сессию [REPL](https://ru.wikipedia.org/wiki/REPL). Основная подсказка `>>>` предлагает ввести команду, вторичная подсказка `...` сигнализирует о продолжении предыдущей инструкции:

```python
>>> def hello():
...     print("Hello world")
...
>>>
```

Пользователь вводит инструкции python и немедленно получает ответ. В режиме REPL Python может использоваться как продвинутый калькулятор:

```python
Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:21:23) [MSC v.1916 32 bit (In
tel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> a = 3
>>> b = 3
>>> a * b + 5
14
>>>
```

Введите Ctrl+Z для завершения сессии интерпритатора.

### 3.2 Операторы Python, строки и отступы

Программа на Python состоит из логических строк ограниченных токеном **NEWLINE**. Каждая логическая строка эквивалентна простому оператору. Составные операторы формируются из нескольких логических строк.

Логическая строка создаётся из одной или нескольких физических строк используя явные или не явные правила объединения строк. Физическая строка — это последовательность символов завершающаяся символами перевода строки (end-of-line sequence). Python неявно рассматривает физические строки как логические, устраняя необходимость в точке с запятой для разделения выражений. Однако точка с запятой может использоваться для разделения одной физической строки на несколько логических:

```Python
>>> i = 5; print i;
5
```

Несколько физических строк в явном виде объединяются в одну логическую символом "\\":

```Python
>>> name = "Obi Ike-Nwosu"
>>> cleaned_name = name.replace("-", " "). \
... replace(" ", "")
>>> cleaned_name
'ObiIkeNwosu'
>>>
```

Физические строки соединяются неявно, без использования символа продолжения строки ("\\"), когда выражение находится в тройных строковых кавычках, заключено в скобки `(...)`, `[...]`, или `{...}`.

Python содержит два типа операторов.

Простые операторы занимающие одиночные логические строки. Они включают в себя присваивание, **yield** и др. Общий синтаксис простых операторов:

```
simple_stmt ::= expression_stmt
            | assert_stmt
            | assignment_stmt
            | augmented_assignment_stmt
            | pass_stmt
            | del_stmt
            | return_stmt
            | yield_stmt
            | raise_stmt
            | break_stmt
            | continue_stmt
            | import_stmt
            | global_stmt
            | nonlocal_stmt
```

Составные операторы занимающие несколько логических строк. Они включают в себя выражения циклов **while** и **for**. Общий синтаксис составных операторов:

```
compound_stmt ::= if_stmt
              | while_stmt
              | for_stmt
              | try_stmt
              | with_stmt
              | funcdef
              | classdef

suite ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT

statement ::= stmt_list NEWLINE | compound_stmt

stmt_list ::= simple_stmt (";" simple_stmt)* [";"]
```

Составные операторы содержат одно или несколько предложений (clause). Предложение состоит из заголовка (header) и тела (suite). Заголовки предложений для одного составного оператора имеют одинаковый отступ и начинаются с уникального идентификатора (**while**, **if** и т.д.) и с двоеточия. Составной оператор **if** определяется так:

```
if_stmt ::=  "if" expression ":" suite
             ( "elif" expression ":" suite )*
             ["else" ":" suite]
```

Выполнение тела предложения контролируется заголовком:

```Python
>>> num = 6
# оператор if является составным оператором
    # Заголовок предложения контролирует выполнение следующего блока с отступом
>>> if num % 2 == 0:
        # блок тела с отступом
...     print("The number {} is even".format(num))
...
The number 6 is even
>>>
```

Тело (suite) может быть набором из одного или нескольких операторов который следуют за двоеточием заголовка, в этом случае, операторы разделяются точкой с запятой:

```Python
>>> x = 1
>>> y = 2
>>> z = 3
>>> if x < y < z: print(x); print(y); print(z)
...
1
2
3
```

Но обычно тело (suite) записывается со следующей после заголовка строки в виде одного или нескольких операторов с отступом:

```Python
>>> x = 1
>>> y = 2
>>> z = 3
>>> if x < y < z:
...    print(x)
...    print(y);
...    print(z)
...
1
2
3
```

Отступы используются для обозначения блоков кода таких как тела функций, условий, циклов и классов. Ведущий пробел в начале логической строки используется для вычисления отступа для этой строки, который, в свою очередь, используется для определения группировки оператора. Отступ используемый в теле блока всегда должен совпадать с отступом первого оператора в блоке.

### 3. Строки

Строки в Python обрамляются двойными "..." или одинарными '...' кавычками. Спецсимволы указываются внутри строки с экранированием:

```python
# кавычка используется как апостроф, поэтому мы экранируем её чтобы 
# предотвратить завершение строки
>>> name = 'men\'s'
>>> name
"men's"
>>>
```

Для того чтобы отключить обработку спецсимволов в строке, добавьте перед строкой символ **r**:

```python
>>> print('C:\some\name') # здесь \n означает перевод строки!
C:\some
ame
>>> print(r'C:\some\name') # добавлен r перед кавычкой
C:\some\name
```

Многострочные строковые литералы задаются тройными кавычками. Перевод строки автоматически добавляется при достижении конца строки:

```python
>>> para = """hello world I am putting together a
... book for beginners to get to the next level in python"""
# Обратите внимание на символ перевод строки
>>> para
'hello world I am putting together a \nbook for beginners to get to the next level in python'
# При выводе текст разделяется на несколько срок
>>> print(para)
hello world I am putting together a
book for beginners to get to the next level in python
>>>

Чтобы перевод строки не добавлялся используйте символ **\** в конце строки:

​```python
>>> para = """hello world I am putting together a \
... book for beginners to get to the next level in python"""
>>> para
'hello world I am putting together a book for beginners to get to the next level in python'
>>> print(para)
hello world I am putting together a book for beginners to get to the next level in python
>>>
```

Строки неизменяемые, один раз созданная строка не может быть изменена. Для символов отдельного типа нет, они являются строками длинной в 1 символ. Строки являются одним из типов последовательностей, поэтому поддерживают все операции с последовательностями, за исключением присваивания по индексу из-за неизменяемости. Обращение к отдельному символу происходит по индексу:

```python
>>> name = 'obiesie'
>>> name[1]
'b'
>>>
```

Строки соединяются оператором **+**:

```python
>>> name = 'obiesie'
>>> surname = " Ike-Nwosu"
>>> full_name = name + surname
>>> full_name
'obiesie Ike-Nwosu'
>>>
```

Написанные рядом строковые литералы соединяются автоматически:

```python
>>> 'Py' 'thon'
'Python'
>>>
```

Встроенная функция **len** возвращает длину строки:

```python
>>> name = "obi"
>>> len(name)
3
>>>
```

### 3.4 Управляющие конструкции

#### if-else и if-elif-else

Оператор **if** применяется для условного выполнения блока кода:

```python
>>> name = "obi"
>>> if name == "obi":
...     print("Hello Obi")
...
Hello Obi
>>>
```

За оператором **if** следует ноль или больше операторов **elif** и не обязательный оператор **else**. Если не один из операторов **if** или **elif** не был выполнен, то выполняется блок **else**:

```python
>>> if name == "obi":
...     print("Hello Obi")
... elif name == "chuks":
...     print("Hello chuks")
... else:
...     print("Hello Stranger")
Hello Stranger
>>>
```

#### for и range

В Python два вида циклов: **while** и **for**.

Оператор **for** используется для перебора последовательностей (list, set, tuple и т.д.). В общем случае, цикл **for** используется для перебора любых объектов реализующих протокол итератора Python (python iterator protocol). Подробнее это будет описано в следующих главах.

Пример использования цикла **for**:

```python
>>> names = ["Joe", "Obi", "Chris", "Nkem"]
>>> for name in names:
...     print(name)
...
Joe
Obi
Chris
Nkem
>>>
```

Большинство языков программирования использует синтаксис похожий на этот для перебора последовательности чисел:

```
for(int x = 10; x < 20; x = x+1) {
// do something here
}
```

В Python используется конструкция **range()** для генерации арифметической прогрессии целых чисел:

```python
>>> for i in range(10, 20):
...     print i
...
10
11
12
13
14
15
16
17
18
19
```

Функция range(start, stop, step) допускает три аргумента. Значение параметра **stop** не входит в возвращаемую последовательность.

#### while

Оператор **while** выполняет блок кода пока условное выражение вычисляется в **True**:

```python
>>> counter = 10
>>> while counter > 0: # условное выражение 'counter > 0'
...     print(counter)
...     counter = counter - 1
...
10
9
8
7
6
5
4
3
2
1
```

#### break и continue

Команда **break** завершает выполнение цикла, после **break** происходит немедленный выход из цикла.

```python
>>> for i in range(10):
...     if i == 5:
...         break
...     else:
...         print(i)
...
0
1
2
3
4
```

Команда **continue** принудительно запускает следующую итерацию цикла. Все команды внутри цикла после **continue** игнорируются.

```python
>>> for i in range(10):
        # если i равно 5 то начинаем новую итерацию цикла, без выполнения остальных команд
...     if i == 5:
...         continue
...     print("The value is " + str(i))
...
The value is 0
The value is 1
The value is 2
The value is 3
The value is 4
# no printed value for i == 5
The value is 6
The value is 7
The value is 8
The value is 9
```

В примере выше, значение 5 не напечатано, из-за условия и команды **continue**. Все остальные значения напечатаны.

#### циклы и else 

В Python ключевое слово **else** применяется вместе с операторами цикла. Блок после **else** выполняется если цикл не был завершён оператором **break**.

```python
# loop exits normally
>>> for i in range(10):
...     print(i)
... else:
...     print("I am in quirky else loop")
...
0
1
2
3
4
5
6
7
8
9
I am in quirky else loop
```

Если цикл завершён оператором **break**, то блок **else** пропускается:

```python
>>> for i in range(10):
...     if i == 5:
...        break
...     print(i)
... else:
...     print("I am in quirky else loop")
...
0
1
2
3
4
```

#### Enumerate

Иногда нужно перебрать коллекцию, поучая одновременно индекс и значение элементов. Можно использовать такой подход:

```python
>>> names = ["Joe", "Obi", "Chris", "Jamie"]
>>> name_count = len(names)
>>> index = 0
>>> while index < name_count:
...   print("{}. {}".format(index, names[index]))
...   index = index + 1
...
0. Joe
1. Obi
2. Chris
3. Jamie
```

В Python есть более эффективное решение с функцией **enumerate**:

```python
>>> for index, name in enumerate(names):
...     print("{}. {}".format(index, name))
...
0. Joe
1. Obi
2. Chris
3. Jamie
>>>
```
### 3.5 Функции

Именованные функции определяются ключевым словом **def**, за которым следует название функции и список параметров в скобках. Ключевое слово **return** используется для возвращения значения функции:

```python
def full_name(first_name, last_name):
    return " ".join((first_name, last_name))
```

Для вызова функции используется её имя, параметры передаются в скобках:

```python
full_name("Obi", "Ike-Nwosu")
```

Функции могут вернуть несколько значений в виде кортежа. В следующим примере функция возвращает частное и остаток от деления:

```python
>>> def divide(a, b):
...     return divmod(q, r)
...
>>> divide(7, 2)
(3, 1)
>>>
```

Функция без **return** всегда возвращает **None**:

```python
>>> def print_name(first_name, last_name):
...     print(" ".join((first_name, last_name)))
...
>>> print_name("Obi", "Ike-Nwosu")
Obi Ike-Nwosu
>>> x = print_name("Obi", "Ike-Nwosu")
Obi Ike-Nwosu
>>> x
>>> type(x)
<type 'NoneType'>
>>>
```

Ключевое слово **return** может использоваться без значения чтобы прервать выполнение функции:

```python
>>> def dont_return_value():
...     print("How to use return keyword without a value")
...     return
...
>>> dont_return_value()
```

Выражение **lambda** позволяет объявить функцию без имени. Такая функция состоит всего из одного выражения которое и является значением функции. Поэтому не требуется использовать **return**.


```python
>>> square_of_number = lambda x: x**2
>>> square_of_number
<function <lambda> at 0x101a07158>
>>> square_of_number(2)
4
>>>
```

Функция созданная через **lambda** эквивалентна именованной функции определённой через **def**.

### 3.6 Структуры данных

Python содержит встроенные типы данных: списки, кортежи, словари.

#### Списки

Списки создаются используя квадратные скобки или функцию `list()`:

```python
my_list1 = [] # Пустой список
my_list2 = list() # Пустой список
```

Список сохраняет порядок элементов с которым создаётся или в котором элементы добавляются. Списки являются последовательностями и поддерживают доступ по индексу, другие свойства последовательностей будут описаны в следующих главах. 

Первый элемент списка находится под индексом 0, последний — на единицу меньше длины списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name[0]
'obi'
>>> name[1]
'ike'
>>> name[2]
'nwosu'
```

Метод `append()` добавляет элемент в список.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name.append("nkem")
>>> names
["obi", "ike", "nwosu", "nkem"]
```

Метод `insert()` добавляет элемент в любое место списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name.insert(1, "nkem")
>>> names
["obi", "nkem", "ike", "nwosu"]
```

Оператор `+` позволяет объединить два и более списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name1 = ["James"]
>>> name + name1
["obi", "ike", "nwosu", "James"]
```

Для просмотра всех методов списка запустите команду `help(list)`.

#### Кортежи

Кортеж тоже является последовательностью и создается элементами разделёнными запятыми:

```python
>>> companies = "Google", "Microsoft", "Tesla"
>>> companies
('Google', 'Microsoft', 'Tesla')
```

При определении непустого кортежа скобки не обязательны, но они становятся обязательными когда кортеж является частью большего выражения. Пустой кортеж создаётся пустой парой скобок:

```python
>>> companies = ()
>>> type(companies)
<class 'tuple'>
```
При определении кортежа с одним элементом запятая за ним обязательна.

```python
>>> company = "Google",
>>> type(company)
<class 'tuple'>

>>> company = ("Google",)
>>> type(company)
<class 'tuple'>
```

Пропуск запятой означает что задано обычное значение, не кортеж.

```python
>>> company = ("Google")
>>> company
'Google'

>>> type(company)
<class 'str'>
```

Кортежи индексируются как списки, но неизменямы.

```python
>>> companies = ("Google", "Microsoft", "Palantir")
>>> companies[0]
'Google'
>>> companies[0] = "Boeing"
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

В тоже время, если элементом кортежа является изменяемые объект, такой как список, то он может быть изменен.

```python
>>> companies = (["lockheedMartin", "Boeing"], ["Google", "Microsoft"])
>>> companies
(['lockheedMartin', 'Boeing'], ['Google', 'Microsoft'])
>>> companies[0].append("SpaceX")
>>> companies
(['lockheedMartin', 'Boeing', 'SpaceX'], ['Google', 'Microsoft'])
```

#### Множества

Множества это неупорядоченные коллекции объектов не содержащие дубликатов. Пустое множество создаётся функцией `set()` или круглыми скобками `{}`.  Множества неупорядоченны поэтому к элементам множества нельзя обратится по индексу. Множества, за исключением frozen set, изменяемы.

```python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> basket_set = set()
>>> basket_set
set()
>>> basket_set.update(basket)
>>> basket_set
{'pear', 'orange', 'apple', 'banana'}
>>> basket_set.add("clementine")
>>> basket_set
{'pear', 'orange', 'apple', 'banana', 'clementine'}
>>> basket_set.remove("apple")
>>> basket_set
{'pear', 'orange', 'banana', 'clementine'}
```

#### Словари

Словарь в Python похож на ассоциативный массив или хеш-таблицу в других языках. Словари индексируются по неизменяемому ключу. Для создания словаря используются фигурные скобки `{}` или функция`dict()`. Словарь — неупорядоченное множество пар ключ-значение в которых ключ уникален. Пример инициализации словаря:

```python
ages = {"obi": 24,
"nkem": 23,
"Chris": 23
}
```

Основные операции словаря это сохранение значения по ключу и доступ к значению по ключу. Доступ к значению осуществляется через квадратные скобки:

```python
>>> ages["obi"]
24
```

Словари изменяемы, значения связанные с ключами могут менятся, добавлятся и удалятся.

Структуры данных Python не ограничиваются приведёнными в этом разделе. Например, модуль `collections` содержит очереди, деки и другие коллекции. В то же время структуры приведённые в этом разделе используются в большинстве приложений на Python.

Используйте функцию help с параметром в виде названия типа данных для детального изучения типа.

```python
help(list)
help(tuple)
help(set)
help(dict)
```

### 3.7 Классы

Выражение `class` используется для определения новых типов в Python:

```python
class Account:
    # классовая переменная общая для всех экземпляров классов
    num_accounts = 0

    def __init__(self, name, balance):
    # переменные экзепляра
    self.name = name
    self.balance = balance
    
    # изменение классовой переменной 
    Account.num_accounts += 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)

    @classmethod
    def from_dict(cls, params):
        params_dict = json.loads(params)
        return cls(params_dict.get("name"), params_dict.get("balance"))
```

Классы в Python, как в других языках, могут содержать классовые пеменные, переменные объекта, классовые методы, статичные методы и методы объекта. 

При определении класса, имя родителського класса указывается в скобках после названия класса.

```python
class dog(animal):

```

Метод `__init__` похож на конструктор в других языках программирования. В этом методе инициализируются переменные объекта. Для создания объекта класса `Account` нужно передать аргументы указанные в `__init__` за исключением `self`:

```python
>>> acct = Account("obie", 10000000)
```

Методы обявленные с аргументом `self` являются методами объекта. Аргумент `self` является ссылкой на объект. Методы вызываются через точку:

```python
>>> acct = Account("obie", 10000000)
>>> account.inquiry()
Name=obie, balance=10000000
```

Встроенная функция `dir` предназачена для исследования объектов и печатает все методы, переменные и атрибуты объекта который в неё передан.

### 3.8 Модули

С ростом размера и сложности кода он всё больше нуждается в структуризации. Python позволяет разделить кода на несколько файлов. Каждый файл назвывается модулем имеет расширений `.py`. Для обращения к определениям из файла его необходимо имортировать командой `import`. 

```python
>>> import Account
>>> acct = Account.Account("obie", 10000000)
```

Команда `import` требует имя модуля без расширения `.py`.  При иморте создается пространство имён с именем модуля (в примере `Account`). Доступ к определням из пространства имён осуществляется через точку (`.`).

Ключевое слово `as` задаёт название пространство имён отличное от названия модуля:

```python
>>> import Account as acct
>>> account = acct.Account("obie". 10000000)
```

Возможнен иморт отдельных определений из модуля вместо всего модуля:

```python
>>> from Account import Account
>>> account = Account("obie", 10000000)
```

Возможно импортрровать все опредления из модуля:

>>> from Account import *

Такой способ не рекуомендуется, так как приводит к конфликтам разных пространств имён: импортированные имена из одного модуля перезаписываются импортом из другого.

Модули это обычные объекты Python, их можно исследовать функцией `dir`. Модули могут быть сгруппированы в пакеты. Пакеты и модули детальнее описаны в следующих главах.

### 3.9 Исключения

Python поддерживает исключения и перехват исключений. Например, при делении на ноль интерпритатор выбросит исключение `ZeroDivisionError`.

```python
>>> 2/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>>
```
Во время выполнения программы, исключение генерируется когда происходит ошибка. Если исключение не обработано, то на экран будет выведен стек вызовов. В обычном случае необработанное исключение остановит выполнение программы.

Исключения перехватываются командой `try...catch`:

```python
>>> try:
...     2/0
... except ZeroDivisionError as e:
...     print("Attempting to divide by 0. Not allowed")
...
Attempting to divide by 0. Not allowed
>>>
```
Исключения бывают разных типов. В примере выше обрабатывается исключение `ZeroDivisionError` и если в защищенном коде возникнет другое исключение, то работа программы остановится.

Для перехвата любого исключения тип исключения не указывается

```python
>>> try:
...     2/0
... except:
...     print("Attempting to divide by 0. Not allowed")
...
Attempting to divide by 0. Not allowed
>>>
```
Такая конструкция не рекомендуется, так как невозможно сказать какой тип возникшего исключения.

Для объявления пользовательского типа исключения создаётся класс наследуемый от `Excption`. Пользовательские исключения перехватываются тем же способом что и стандартные.

### 3.10 Ввод и вывод

Python поддерживает операции ввода и вывода из разных источников. Пример чтения файла:

```python
f = open("afile.txt")
line = f.readline()
while line:
    print(line)
    line = f.readline()
```

Метод `open` возвращает объект типа `file` или генерирует исключение если файл не сущетвует. Объект типа `file` поддерживает методы такие как чтение всего файла в строку (`read`) или чтение одной строки файла (`readline`). Python поддерживает синтаксический сахар для перебора всех строк файла:

```python
for line in open("afile.txt"):
    print(line)
```

Пример записи в файл:

```python
f = open("out.txt", "w")
contents = ["I", "love", "python"]
for content in contents:
    f.write(content)
f.close()
```

Python так же поддерживает запись в стандартный поток вывода и чтение из стандартного потока ввода.

```python
name = input('What is your name? ')
print(f'Hello, {name}')
```

### 3.11 Документация

Интерпретатор Python содержит много встроенной документации. Для получения документации используйте команду `help`, в параметре передаётся название класса или онструкции языка.

```python
help('try')
help(list)
```

## 4.  Intermezzo: Глоссарий

В этой книге используются термины и эзотерический функции Python понимание которые является условием глубокого понимания Python. Ниже даётся объяснение этих терминов и функций.

### 4.1 Имена и связывание

В Python, на объекты ссылаются через имена. Имена аналогичны переменным в C++ или Java.

```
>>> x = 5
```

В примере выше, `x` &mdash; имя которое ссылается на объект `5`. Процесс присваивания ссылки на `5` в `x` называется связыванием. Связывание приводит к тому что имя ассоциируется с объектом. 

Связывание происходит в разных ситуациях: при присваивании и при вызове методов, когда параметры связываются с аргументами.

Важная особенность: **имена являются только ссылками без связанного с ними типа; имена ссылаются на объекты которые имеют тип**.

Присваивание создаёт новое имя в самой внутренней области видимости программы: если присваивание выполняется в коде модуля &mdash; имя добавляется в глобальные переменные модуля, если в коде функции &mdash; в локальные переменные функции.

### 4.2 Блоки кода

Блок кода это часть программы запускаемая как одно целое. Модули, функции и класс являются примерами блоков кода. Команды вводимые в REPL скрипты запущенные с опцией `-c` тоже блоки кода. Блок кода содержит пространства имён связанные с ним. Например, блок кода модуль имеет доступ к глобальному пространству имён, а блок кода функция имеет доступ к локальному и глобальному пространству имён.

### 4.3 Пространства имён

Пространство имён — контекст в котором данное множество имён связано с объектами. Сейчас пространства имён реализованы в виде словаря. Например, пространство имён встроенных функций реализуется словарём `__builtins__.__dict__`.

Интерпретатору доступны несколько пространств имён, включая глобальное пространство имён, пространство имён встроенных функций и локальное пространство имён. Эти пространства имён создаются в разное время и имеют разное время жизни. 

Например, локальное пространство имён создаётся при вызове функции и уничтожается при выходе из функции. Глобальное пространство имён создаётся в начале запуска модуля и все имена определённые в нём доступны для всего модуля. Пространство имён встроенных функций создаётся при запуске интерпретатора и содержит все встроенные имена. Эти три основные пространства имён доступные интерпретатору.


### 4.4 Области видимости

Область видимости это часть программы в которой множество имён (пространств имён) видимы и доступны напрямую. Прямой доступ важная характеристика области видимости и будет объяснена при разговоре о классах. В простом смысле, это означает что имя может использовать как есть, без использования точки для доступа к имени, как например `SomeClassOrModule.name`. Во время выполнения следующие области видимости могут быть доступны

1. Самая внутренняя область видимости с локальными именами.
2. Область видимости внешней функции если она есть (для вложенных функций)
3. Глобальная область видимости текущего модуля
4. Пространство имён встроенных функций

При использовании имени интерпретатор ищет в пространствах имён областей видимости в порядке указном выше и если имя не найдено генерирует исключение.

Python поддерживает статическое пространство имён (static scoping,  lexical scoping). Это означает что для определения того какая переменная используется в данном блоке достаточно просмотра текста программы. TODO Link

#### Примечание

Python содержит правила предотвращающие изменение имени в глобальной области видимости из локальной области области видимости. Попытка сделать это приведёт к исключению `UnboundLocalError`.

```python
>>> a = 1
>>> def inc_a(): a += 2
...
>>> inc_a()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 1, in inc_a
UnboundLocalError: local variable 'a' referenced before assignment
```

Для изменения объекта из глобальной области видимости в локальной области видимости применяется ключевое слово `global`. Оно должно использоваться до того как происходит изменение объекта.

```python
>>> a = 1
>>> def inc_a():
...     global a
...     a += 1
...
>>> inc_a()
>>> a
2
```

Ключевое слово `nonlocal` используется при необходимости изменения привязки переменной во внешней не глобальной области видимости из внутренней области видимости. Это полезно во вложенных функциях (замыканиях). Пример использования `nonlocal` при определении объектов-счётчиков: 

```python
>>> def make_counter():
...     count = 0
...     def counter():
...         nonlocal count # nonlocal captures the count binding from enclosing scope not global scope
...         count += 1
...         return count
...     return counter
...
>>> counter_1 = make_counter()
>>> counter_2 = make_counter()
>>> counter_1()
1
>>> counter_1()
2
>>> counter_2()
1
>>> counter_2()
2
```

### 4.5 eval()

Встроенная функция `eval` запускает выражение Python переданное в виде строки или объекта типа `code`. Сигнатура функции:

```python
eval(expression, globals=None, locals=None)
```

При вызове `eval` возвращает результат выражения:

```python
>>> eval("2 + 1") # note the expression is in a string
3
```

Аргумент `globals` должен быть словарём, а `locals` может быть любым отображением. Если `globals` не задан то вместо него используется текущее глобальное пространство имён. Это означает что у кода будет доступ ко всем именам текущего модуля.

```python
def g():
    return 4

print(eval('2 + 2 + g()')) # 8
```

Вместо строки в `eval` можно передать объект типа `code` полученный функцией `compile`.  `eval` и `exec` используется для запуска произвольного Python кода, например, в онлайн интерпретаторах Python.

### 4.6 exec()

`exec` похож на `eval`, он запускает строку (или объект типа `code`) с набором команд Python. Сигнатура `exec`:

```python
exec(object[, globals[, locals]])
```

Пример использования `exec` используя строку и текущее пространство имён:

```python
Python 3.4.2 (v3.4.2:ab2c023a9432, Oct 5 2014, 20:42:22)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.

>>> cont = open('acct.py', 'r').read()

>>> cont
'class Account:\n """base class for representing user accounts"""\n num_accounts = 0\n\n de\
f __init__(self, name, balance):\n self.name = name \n self.balance = balance \n \
Account.num_accounts += 1\n\n def del_account(self):\n Account.num_accounts -= 1\n\n \
def __getattr__(self, name):\n """handle attribute reference for non-existent attribute"""\n \
return "Hey I dont see any attribute called {}".format(name)\n\n def deposit(self, amt):\n\
self.balance = self.balance + amt \n\n def withdraw(self, amt):\n self.balance = s\
elf.balance - amt \n\n def inquiry(self):\n return "Name={}, balance={}".format(self.name,\
self.balance) \n\n'

>>> exec(cont)
# запускаем содержимое файла используя пространство имён по умочанию
>>> Account # теперь мы можем ссылаться на класс Account
<class '__main__.Account'>
>>>
```

Если необязательные аргументы пропущены когда запускается в текущей области видимости. Если задан только `global` то они используется для глобальных и локальных переменных. 

Если словарь переданный в `global` не содержит  ключа `__builtins__` то под этим ключом будет добавлена ссылка на пространство имён встроенных функций. Вставив под ключом `__builtins__` свой словарь можно добиться запрета или ограничения стандартных функций.

## 5. Objects 201

Любое значение в Python является объектом. Любой объект имеет идентификатор, тип и значение. Идентификатор объекта не меняется после создания объекта. 

Функция `id(obj)` возвращает идентификатор объекта. В CPython идентификатор объекта это адрес объекта в памяти. В других реализациях Python идентификатор объекта может генерироваться по другому принципу, но он обязательно должен уникально идентифицировать объект в интерпретаторе.

```python
>>> n = 5
>>> id(5)
1573971952
```

Оператор `is` сравнивает идентификаторы двух объектов и возвращает логическое значение.

```python
>>> n1 = 6
>>> n2 = 7
>>> n1 is n2
False
```

Функция `type()` возвращает тип объекта, тип тоже сам является объектом. Тип объекта, при нормальной работе, неизменяем. Тип объекта определяет операции которые поддерживает объект и возможный набор значений. Python динамический язык программирования потому что типы не связаны с переменными, так что переменная `x` сначала может ссылаться на число, а через некоторое время на строку.

```python
x = 1
x = "Nkem"
```

В тоже время Python является строго типизированным языком, так как интерпретатор не меняет тип объекта автоматически. Это, например, означает что при сложении строки и числа будет сгенерировано исключение:

```python
>>> x = "Nkem"
>>> x + 1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
```

Такое поведение отлично от других языков, например, от JavaScript где интерпретатор неявно конвертирует число в строку и соединит их.

Объекты Python бывают двух типов: изменяемые и неизменяемые.

**Изменяемые объекты**

Значения изменяемых объектов могут меняться. Например, список относится к изменяемым объектам, в него можно добавлять или удалять элементы:

```python
>>> a = [1, 2]
>>> a.append(3)
>>> a
[1, 2, 3]
```

Значения в Python всегда передаются по ссылке, это, в частности, означает что при передачи ссылки на значение в метод (любой объект), внутри метода будет использоваться ссылка на то же значение. Демонстрация такого поведения:

```python
>>> x
[1, 2, 3]
>>> y = x
# теперь x и y ссылаются на один список
>>> x.extend([4, 5, 6])
# изменение в x отражаются в y
>>> y
[1, 2, 3, 4, 5, 6]
```
`x` и `y` ссылаются на один объект поэтому неважно через какую ссылку было произведено изменение объекта. Важно понимать что `x` не содержит список, а только ссылку на него и при присваивании `y = x` в `y` так же помещается только ссылка на тот же самый список.

**Неизменяемые объекты**

Неизменяемые объекты не могут изменить своё значение. Кортежи являются неизменяемыми объектами: 

```python
>>> x = (1, 2, 3, 4)
>>> x[0]
1
>>> x[0] = 10
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>>
```

Неизменяемые объекты могут содержать изменяемые объекты. В этом случае значения изменяемых объектов может быть изменено, но не ссылка на сам изменяемый объект. Таким случаем является список внутри кортежа:

```python
>>> t = [1, 2, 3, 4]
>>> x = t,
>>> x
([1, 2, 3, 4],)
>>> x[0]
[1, 2, 3, 4]
>>> x[0].append(10)
>>> x
([1, 2, 3, 4, 10],)
>>>
```

###  5.1 Слабые и сильные ссылки на объекты

Объекты Python получают ссылки когда они связываются с именами. Связывание может произойти после присваивания, вызова метода с параметрами или другими способами. Каждый раз когда объект получает ссылку увеличивается счётчик ссылок. Значение счётчика ссылок можно получить функцией `sys.getrefcout()`:

```python
import sys

l = []
m = l

print(sys.getrefcount(l)) # 3
```
В примере три ссылки: `l`, `m` и ссылка из параметра `getrefcount`.

В Python применяется два типа ссылок: слабые и сильные. Если это точно не указано, то при упоминании ссылок речь идет о сильных ссылках, как в приведенном выше примере три сильные ссылки.

Главная особенность сильных ссылок — когда они создаются то счётчик ссылок увеличивается на 1. Сборщик мусора не удалит объект на который есть сильная ссылка, так как он удаляет только объекты счетчик ссылок которых равен 0.

Слабые ссылки не увеличивают счётчик ссылок объекта. Модуль `weakref` предназначен для работы со слабыми ссылками:

```python
import sys
import weakref


class Foo:
    pass


a = Foo()
b = a
print(sys.getrefcount(a)) # 3

c = weakref.ref(a)
print(sys.getrefcount(a)) # 3

print(c()) # <__main__.Foo object at 0x01481F88>
print(type(c)) # <class 'weakref'>
```

Функция `weakref.ref` возвращает объект при вызове которого (как вызов функции `c()`) возвращается объект на который слабая ссылка. Другая функция `weakref.proxy` так же создаёт слабую ссылку и возвращает объект который может использоваться как оригинальный объект без необходимости вызова:

```python
import sys
import weakref


class Foo:
    pass

    def get(self):
        return 23


a = Foo()
b = weakref.proxy(a)
print(sys.getrefcount(a)) # 2

print(b) # <__main__.Foo object at 0x03911F88>
print(b.get()) # 23
```

Когда все сильные ссылки на объект удалены, слабые ссылки тоже ссылку на объект и объект готов для уничтожения сборщиком мусора.

```python
import weakref


class Foo:
    pass


a = Foo()
b = weakref.ref(a)

del a

print(b) # <weakref at 0x03799AF0; dead>
print(b()) # None
```

### 5.2 Иерархия типов

В этом разделе перечислены категории встроенных типов Python.

#### Тип None

The None type is a singleton object that has a single value and this value is accessed through the built-in name None. 

Тип **None** это синглтон который содержит только одно значение и это значение доступно под встроенным именем `None`. Этот тип используется для обозначеия отсутствия значения, например, когда функция не возвращает значения в явном виде:

```python
def print_name(name):
    print(name)


name = print_name("nkem")

print(name) # None
print(type(name)) # <class 'NoneType'>
```

При преобразованию к логическому типу `None` становится `False`:

```python
print(bool(None)) # False
```

#### Тип NotImplemented

Тип **NotImplemented** так же является синглтоном с одним значением. Значение этого объекта доступно под встроенным именем `NotImplemented`. Такой объект используется чтобы делегировать поиск реализации метода интерпретатору вместо генерации исключений `NotImplementedError`:


```python
class Foo:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        if isinstance(other, Foo):
            print('Сравнение экземпляра Foo с другим экземпляром Foo')
            return other.value == self.value

        elif isinstance(other, Bar):
            print('Сравнение экземпляра Foo с экземпляром Bar')
            return other.value == self.value

        print('Невозможно сравнить экземпляр Foo с другим классом')
        return NotImplemented


class Bar:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        if isinstance(other, Bar):
            print('Сравнение экземпляра Bar с другим экземпляром Bar')
            return other.value == self.value

        print('Невозможно сравнить экземпляр Bar с другим классом')
        return NotImplemented
```

Эффект возврата `NotImplemented` наблюдается при попытке сравнения. `a == b` приводят к вызову `a.__eq__(b)`. В примере, классы `Foo` и `Bar` содержат реализацию для сравнения себя с другими объектами:

```python
f = Foo(1)
b = Bar(1)

res = f == b # Сравнение экземпляра Foo с экземпляром Bar
print(res) # True

res = f == f # Сравнение экземпляра Foo с другим экземпляром Foo
print(res) # True

res = b == f # Сравнение экземпляра Bar с другим экземпляром Bar
print(res) # True
```

If b is compared with f then b.__eq__(f) is invoked and the NotImplemented object is returned
because the implementation of __eq__() in Bar only supports comparison with a Bar instances.

Если `b` сравнивается с `f` то вызывается `b.__eq__(f)` и возвращается объект `NotImplemented`, так как реализация в `Bar` поддерживает сравнение только с экземпляром `Bar`. Несмотря на это операция сравнения будет выполнена:

```python
res = b == f
# Сравнение экземпляра Bar с другим экземпляром Bar
# Сравнение экземпляра Foo с экземпляром Bar
print(res) # True
```

Вызов  метода `b.__eq__(f)` возвращает `NotImplemented` заставляю интерпретатор вызывать `__eq__()` у объекта класса `Foo` и так как в этом методе сравнение реализовано, возвращается корректный результат сравнения.

Объект `NotImplmented` преобразовывается к логическому типу как `True`.

```python
print(bool(NotImplemented)) # True
```

#### Тип Ellipsis

Это ещё один синглтон с одним объектом-значением. Значение этого объекта доступно через литерал `...` или встроенное имя `Ellipsis`. Логическое значение этого объекта True:

```python
print(bool(...)) # True
```
Объект `Ellipsis` используется для индексации матриц, подробнее о нем написано в [документации по numpy](https://docs.scipy.org/doc/numpy/user/basics.indexing.html).

#### Числовые типы

Объекты числовых типов неизменяемы, созданное однажды значение не может быть изменено. Числовые типы делятся на несколько категорий.

**Целые числа**

Класс `int` представляет множество  положительных и отрицательных целых чисел. Целые числа не ограничены размером:

```python
print(238**238)
#42200323427409150751742179532592018252808661114071266629718376939092568551075505740268077803623642715001998769421215763628719631633378375087756319383725641630331895773386010866243028159828607385899087848942302738709343403640250275314218243930567432731458807734886574283968918955323573297631562415292893276034393336066052132808455118105272470307339550216091253570417050545677371810192238471803263478546492058686483752405946094606978411379079233793804753705243644236607675749522119768311584522527886912942059070222789851175661909205254663263392466134105108288691503104
```

**Логическое значения**

Тип `bool` представляет значения `True` и `False`.  `bool` является подтипом `int`:

```python
print(type(True).__base__) # <class 'int'>
```

Значения `False` и `True` ведут себя как 0 и 1 соответственно. При конвертации в строку получаются значения "True" и "False":

```python
x = 1
y = True
print(x + y) # 2

a = 1
b = False
print(a + b) # 1

print(b == 0) # True
print(y == 1) # True

print(str(True)) # 'True'
print(str(False)) # 'False'
```

**Числа с плавающей запятой**

Тип `float` представляет числа с плавающей запятой. Точные ограничения этого типа зависят от реализации интерпретатора. В CPython тип `float` соответствует типу `double` в C. 

**Комплексные числа**

Тип `complex` содержит пару числе с типом `float`. 

```python
c = complex(1, 2)
print(c) # (1+2j)
```

Комплексное число можно создать с помощью литерала:

```python
c = 3+5j
print(type(c)) # <class 'complex'>
```

Реальная и мнимая часть комплексного числа доступна как свойства объекта:

```python
c = complex(1, 2)

print(c.real) # 1.0
print(c.imag) # 2.0
```

#### Последовательности

Последовательности это конечные упорядоченные коллекции объектов. Последовательности индексируются целыми числами, в Python допустимо использование отрицательных индексов. Последовательности делятся на две категории: изменяемые и неизменяемые.

##### Неизменяемые последовательности

Неизменяемые последовательности — это коллекции ссылки на объекты в которых не изменяются после создания. В неизменяемой последовательности может быть ссылка на изменяемый объект, в этом случае значение этого изменяемого объекта может манятся, но сама ссылка на этот изменяемый объект навсегда зафиксирована в неизменяемой последовательности.

Например, кортеж (неизменяемая последовательность) содержит список (изменяемая последовательность). Можно изменять элементы входящие в список. Но нельзя поместить в кортеж ссылку на другой список.

```python
t = [1, 2, 3], "obi", "ike"
print(type(t)) # <class 'tuple'>

t[0].append(4) # изменяем список
print(t) # ([1, 2, 3, 4], 'obi', 'ike')

t[0] = [] # попытка изменить ссылку внутри кортежа
# Traceback (most recent call last):
#   File "test.py", line 7, in <module>
#     t[0] = [] # попытка изменить ссылку внутри кортежа
# TypeError: 'tuple' object does not support item assignment
```

Встроенные неизменяемые последовательсти:

* Строки (Strings)
* Байты (Bytes)
* Кортежи (Tuples)

**Strings**

Строки это неизменяемая последовательность символов (точнее Unicode code points). В Python нет отдельного типа для символов, так что символ это просто строка длины 1. Строки в Python могут предствлять все Unicode code points в диапазоне `U+0000 - U+10FFFF`. Для хранения строк используется тип `str`.

```python
print(type('Hello')) # <class 'str'>
```

**Bytes**

Объект типа `bytes` это неизменяемая последовательность 8-битных байт. Каждый байт представлен в виде целого числа от 0 до 255. Литерал вида `b'abc'` и встроенная функция `bytes()` используются для создания объекта Bytes. 

Bytes тесно взаимодействует со строками. Строки внутри представляют собой последовательность байт декодированную с помощью кодировки (например UTF-8). Символы строк могут быть закодированы с помощью разных кодировок в разные последовательности байт.

```python
b = b'abc'
print(b) # b'abc'

print(type(b)) # <class 'bytes'>

# кодирование строки в байты используя кодировку UTF-16
b = bytes('abc', 'utf-16') 
print(b) # b'\xff\xfea\x00b\x00c\x00'


print(b.decode("utf-16")) # 'abc'
print(type(b.decode("utf-16"))) # <class 'str'>

# декодирование строки неудачно, 
# так как символы закодированы в другой кодировке
print(b.decode("utf-8")) 
# Traceback (most recent call last):
#   File "test.py", line 13, in <module>
#     print(b.decode("utf-8")) 
# UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

**Tuple**

Кортеж это последовательность произвольных объектов. Кортеж из двух и более элементов создаётся списком выражений разделённых запятыми. Кортеж из одного элемента создаётся выражением с последующим за ним запятой. Пустой кортеж создаётся пустой парой круглых скобок.

```python
names = "Obi",
print(names) # ('Obi',)
print(type(names)) # <class 'tuple'>

names = () # tuple of 0
print(names)  # ()
print(type(names))  # <class 'tuple'>

names = "Obi", "Ike", 1 # tuple of 2 or more
print(names)  # ('Obi', "Ike", 1)
print(type(names))  # <class 'tuple'>
```

##### Изменяемые последовательности

Значения внутри изменяемых последовательностей могут менятся после создания объекта. Существует два встроенных типа изменяемых последовательностей: массив байт и список.

**Byte Arrays**

Объект `bytearray` это изменяемый массив байт. Он создайтся встроенной функцией `butearray()`.  Кроме того что `bytearray` изменяемый и следовательно нехешируемый он поддерживает тот же интерфейс и функциональность что и неизменяемый `bytes`.  Массив байт наиболее полезен когда требуется эффективность обеспечиваемая его изменяемостью. Например, при приёме неизвестного количество данных по сети, `bytearra` более эффективен так как может быть расширен при приёме новых данных без создания нового объекта как было бы с неизменяемый `bytes`.

**List**

Список это произвольная последовательность объектов Python, это самый широко используемый тип данных в Python. Списки создаётся выражениями разделёнными запятыми в квадратных скобках. Пустой список создаётся парой пустых квадратных скобок. Список может быть создан из любого перечисляемого типа, помещением его в метод `list()`. 

##### Операции с последовательностями

Типы последовательностей поддерживают общий набор операций. Эти операции описаны в таблице ниже.

* x — объект
* s, t — последовательности
* n, i, j, k — целые числа



| Операция | Описание |
| -------- | -------- |
| x **in** s | **True** если `s` содержит элемент равный `x`, **False** если не содержит |
| x **not in** s | **False** если `s` содержит элемент равный `x`, **True** если не содержит |
| s + t | Соединение последовательностей `s` и `t` |
| s * n | `n` поверхностных копий `s` соединённых в одну последовательность |
| s[i] | i-тый элемент `s`, стартовый — 0 |
| s[i:j] | Срез элементов начиная с `i` (включительно) и заканчивая `j` (не включительно) |
| s[i:j:k] | Срез элементов начиная с `i` (включительно) и заканчивая `j` (не включительно) с шагом `k` |
| len(s) | Длина `s` |
| min(s) | Наименьший элемент из `s` |
| max(s) | Наибольший элемент из `s` |
| s.index(x) | Индекс первого появления элемента `x` в `s` |
| s.count(x) | Количество вхождений `x` в `s` |

**Примечание**

Значения `n` равные или меньшие 0 производят пустую последовательность того же типа:

```python
x = "obi"
s = x*-2
print(s) # ''
print(type(s)) # <class 'str'>
```

Оператора `*` осуществляет поверхностное копирование: вложенные структуры не копируются. Это может привести к проблемам, например при попытке копирования вложенного списка:

```python
lists = [[]] * 3 # поверхностное копирование
print(lists) # [[], [], []] все три копии ссылаются на один лист

lists[0].append(3)
print(lists) # [[3], [3], [3]]
```

Список списков можно сделать другим методом:

```python
lists = [[] for i in range(3)]
lists[0].append(3)
lists[1].append(5)
lists[2].append(7)

print(lists) # [[3], [5], [7]]
```

При отрицательном индексе `i` отчёт начинается с конца строки: будет возвращён элемент под индексом `len(s) + i`:

```python
a = ['a', 'b', 'c', 'd']

print(a[-3]) # b
print(a[1])  # b
```

Соединение неизменяемых последовательностей, таких как строки, всегда возвращает новый объект:

```python
name = "Obi"
print(id(name)) # 19428608

name += "Obi" + " Ike-Nwosu"
print(id(name)) # 19375168
```

Python определяет интерфейсы (это самое близкое слово которое мы можем использовать) `Sequences` и `MutableSequences` в библиотеке `collections`. Они определяют все методы которые должны реализовывать изменяемые и неизменяемые последовательности. При разговоре об абстрактных классах, мы рассмотрим эту концепцию детальнее.

##### Множества

Множества это неупорядоченные, конечные коллекции уникальных объектов. Множества неупорядочены, поэтому не могут быть проиндексированы целыми числами. Элементы множества должны быть хешируемы, а следовательно неизменяемы. Хеширование элементов обязательно так как множества в Python реализуются через хеш-таблицы.

Множества Python поддерживают эффективную проверку наличия объекта во множестве, вычисления пересечений, объединений и разности множеств. Элементы множества можно перебирать и функция `len()` возвращает количество элементов множества. Существует два типа множеств: изменяемые (`set`)  и неизменяемые (`frozenset`). Общие методы множеств представлены в следующей таблице:

| Метод                                    | Описание                                                     |
| ---------------------------------------- | ------------------------------------------------------------ |
| len(s)                                   | Возвращает мощность множества                                |
| x **in** s                               | Проверяет является ли `x` элементом `s`                      |
| x **not in** s                           | Проверяет что `x` не является элементом `s`                  |
| disdisjoint(other)                       | Возвращает **True** если множества не имеют общих элементов. Множества являются непересекающимися (disjoint) тогда и только тогда когда их пересечение равно пустому множеству. |
| issubset(other),  set <= other           | Проверяет что каждый элемент из множества есть в другом множестве. |
| set < other                              | Проверяет что множество является строгим подмножеством другого множества (`set <= other` и `set != other`). |
| issuperset(other), set >= other          | Проверяет что каждый элемент в другом множестве есть в текущем множестве. |
| set > other                              | Проверяет что другое множество является строгим подмножеством текущего множества (`set >= other` и `set != other`). |
| union(other, …), set \| other …          | Возвращает новое множество — объединение текущего и указанных множеств. |
| intersection(other, …), set & other & …  | Возвращает новое множество — пересечение текущего и указанных множеств. |
| difference(other, …), set - other - …    | Возвращает новое множество с элементами из текущего множества (`set`) которых нет в другом множестве (`other`) |
| symmetric_difference(other), set ˆ other | Возвращает новое множество с элементами которые есть в текущем множестве (`set`) или в другом множестве (`other`) но не в обоих сразу. |
| copy()                                   | Возвращает поверхностную копию множества.                    |



`frozenset` — класс неизменяемого множества конструктор. Неизменяемое множество хешируется, поэтому может использоваться как элемент другого множества или ключ словаря.

`set` — класс изменяемого множества. Изменяемое множество нехешируемо и не может быть элементом другого множества. Изменяемое множество может быть создано с помощью фигурных скобок `{}`. Специфичные методы для изменяемого множества:

| Метод                                           | Описание                                                     |
| ----------------------------------------------- | ------------------------------------------------------------ |
| update(other, …), set \|= other \| …            | Обновляет множество, добавляет элементы из других множеств (`other`) |
| intersection_update(other, …), set &=other & …  | Обновляет множество, сохраняет только те элементы которые есть в текущем множестве и во всех других множества. |
| difference_update(other, …), set -= other \| …  | Обновляет множество, удаляет из текущего множество элементы которые есть в других множествах |
| symmetric_difference_update(other), setˆ= other | Обновляет множество, сохраняет только те элементы которые есть в одном из множество но не одновременно в обоих. |
| add(elem)                                       | Добавляет элемент в множество                                |
| remove(elem)                                    | Удаляет элемент из множества. Генерирует исключение `KeyError` если элемента нет в множестве. |
| discard(elem)                                   | Удаляет элемент из множества если он есть в множестве.       |
| pop()                                           | Удаляет и возвращает произвольный элемент из множества. Генерирует исключение если множество пустое. |
| clear()                                         | Удаляет все элементы из множества.                           |

##### Отображение

Отображения в Python это конечные множества объектов (значений) индексированные по неизменяемым объектам (ключам). Ключи в отображении должны быть хешируемы поэтому для ключей исключаются изменяемые типы такие как списки, изменяемые множества, другие отображения.

Выражение `a[k]` возвращает элемент отображения `a` под индексом `k`. Это выражение можно использовать для присваивания или оператора `del`.  Словарь является единственным встроенным типом отображений в Python.

Словари создаются последовательностью пар `ключ: значение` разделённых запятыми в фигурных скобках (`{'name': "obi", 'age': 18}`) или функцией `dict()`. 

Основные операции со словарём: добавление, удаление и выбор значений по данному ключу. При добавлении ключа который уже есть в словаре старое значение с которым был ассоциирован ключ теряется. Попытка доступа к значению по несуществующему ключу генерирует исключение `KeyError`. 

Словари являются одним из самых важных типов внутри интерпретатора. Например, пространства имён реализуются через словари: всякий раз когда в программе используется имя, доступ к объекту происходит через словарь. Объекты в своей реализации тоже используют словарь — все атрибуты объекта хранятся в словаре `__dict__`. 

Python поддерживает расширенные формы словаря в библиотеке `collectons`: упорядоченный словарь и `deafaultdict`. 

`OrderedDict` сохраняет порядок ключей к котором они были добавлены.

`defaultdict` вызывает фабричную функцию когда получаемое из словаря значение не существует. Полученное значение сохраняется в словаре и возвращается как результат:


```python
from collections import defaultdict

d = defaultdict(int)

print(d) # defaultdict(<class 'int'>, {})

print(d[7]) # 0
print(d) # defaultdict(<class 'int'>, {7: 0})
```

##### Вызываемый тип

Этот тип поддерживает операцию вызова функции. Операция вызова функции использует круглые скобки `()` после имени типа. В примере ниже функция обвялена `print_name`, операция вызова функции это когда после имени функции появляются скобки `print_name()`.

```python
def print_name(name):
    print(name)
```

Функции не единственные вызываемые типы в Python. Любой объект реализующий специальный метод `__call__` является вызываемым типом. Функция `callable(type)` используется для проверки того что тип вызываемый. 

Встроенные вызываемые типы Python:

* Встроенные функции.
* Определяемые пользователем функции.
* Методы — функции определяемые внутри классов. Методы делятся на методы экземпляров, статические и классовые методы.
* Классы также вызываемые типы. Создание нового объектах происходит через вызов класса (например, `Foo()`).

Каждый из этих типов описан детальнее в следующих главах.

##### Пользовательские типы

Пользовательские типы создаются выражением `class`.  Пользовательские классы имеют тип `type`:

```python
class Foo:
    pass

print(type(Foo)) # <class 'type'>
```

Подробнее пользовательские типы описаны в главе про объектно-ориентированное программирование.

##### Модули

Модули это один способ организовывать код Python, такой же как функции и классы. Модули это объекты, так же как и любое другое значение в Python. Типы модулей создаются системой импорта через команду `import` или вызовом функций `importlib.import_module()` и `import()`.

##### Файловый типы

Объект `file` представляет открытый файл. Встроенная функция [open](https://docs.python.org/3/library/functions.html#open) открывает файл и возвращает объект `file`. Файл может быть открыт в текстовом или бинарном режиме.

Другой способ открытия файла: функция `os.open` создаёт файловый дескриптор, а функция   `os.fdopen` принимает файловый дескриптор и создаёт файловый объект:

```python
import os

fd = os.open("test.txt", os.O_RDWR|os.O_CREAT)

print(type(fd)) # <class 'int'>
print(fd) # 3


fo = os.fdopen(fd, "w")

print(fo) # <_io.TextIOWrapper name=3 mode='w' encoding='UTF-8'>
print(type(fo)) # <class '_io.TextIOWrapper'>
```

Метод `makefile()` объекта `socket` открывает и возвращает объект `file` ассоциированный с сокетом.  

Встроенные объекты `sys.stdin`, `sys.stdout` и `sys.stderr` так же файловые объекты соответствующие стандартным в Python потокам ввода, вывода и ошибок.

##### Встроенные типы

Эти объекты использовуются внутри интерпретатора, но достпны пользователю программы. Они включают в себя объекты: трассировка (`traceback`), код  (`code`), фрейм (`frame`), срез (`slice`).

###### Объект `code`

Объект `code` представляет скомпилированный запускаемый код Python, или байткод. Объект `code` это машинный код для виртуальной машины Python вместе со всем что нужно для его запуска. Такие объекты создаются при компиляции блока кода. Эта запускаемая часть кода может быть запущена функциями `exec` или `eval`. Для лучшего понимания объекта `code` проанализируем этот объект для простой функции:

```python
def return_author_name():
    return "obi Ike-Nwosu"
```

Доступ к объекту `code` через объект функции происходит через аттрибут `__code__`:

```pyhon
def return_author_name():
    return "obi Ike-Nwosu"

print(return_author_name.__code__) 
# <code object return_author_name at 0x00A6D1C0, file "test.py", line 1>
```

Рассмотрим аттрибуты объекта `code`:

```python
print(dir(return_author_name.__code__))
# ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename', 'co_firstlineno', 'co_flags', 'co_freevars', 'co_kwonlyargcount', 'co_lnotab', 'co_name', 'co_names', 'co_nlocals', 'co_posonlyargcount', 'co_stacksize', 'co_varnames', 'replace']
```

Интерес представляют неспециальные методы — методы которые не начинаются с подчеркивания. Краткое описание этих методов дано в таблице:

| Метод          | Описание                                                     |
| -------------- | ------------------------------------------------------------ |
| co_argcount    | Количество аргументов (не включая аргументы `*` или `**`)    |
| co_code        | Строка с байт-кодом                                          |
| co_consts      | Кортеж констант используемых в байт-коде                     |
| co_filename    | Название файла в котором создан объект `code`                |
| co_firstlineno | Номер первой строки в файле исходного кода                   |
| co_flags       | Битовая карта: 1 = optimized \| 2=newlocals \| 4 = `*arg` \| 8=`**arg` |
| co_lnotab      | Закодированное отображение номера строки кода в индекс байт-кода |
| co_name        | Имя с которым объект `code` был определён                    |
| co_names       | Кортеж имён локальных переменных                             |
| co_nlocals     | Количество локальных переменных                              |
| co_stacksize   | Требуемое количество места на стеке виртуальной машины       |
| co_varnames    | Кортеж имён аргументов и локальных переменных                |



Рассмотрим байт-код функции:

```python
print(return_author_name.__code__.co_code )
# b'd\x01S\x00'
```

Такой байт-код обычно бесполезен для исследования объекта `code`. Модуль `dis` генерирует человекочитаемое представление объекта `code`:

```python
import dis

s = dis.dis(return_author_name)
```

```
  2           0 LOAD_CONST               1 ('obi Ike-Nwosu')
              2 RETURN_VALUE
```

Инструкция `LOAD_CONST` читает значение из кортежа `co_const` и помещает его в стек (интерпретатор CPython это стековая виртуальная машина). Инструкция `RETURN_VALUE` забирает значение из вершины стека и возвращает его в вызвавшее блок кода окружение и сигнализирует об окончании выполнения.

Объекты `code` служат нескольким целям при программировании. Они содержат информацию помогающую при интерактивной отладке и предоставляют читаемые трассировки при исключениях.

###### Объект `frame`

Frame objects represent execution frames. Python code blocks are executed in execution frames. The call stack of the interpreter stores information about currently executing subroutines and the call stack is made up of stack frame objects. Frame objects on the stack have a one-to-one mapping with subroutine calls by the program executing or the interpreter. 

Объекты `Frame` представляют кадры выполнения. Блоки кода Python выполняется в кадрах выполнения. Стек вызовов интерпетатора хранит информацию о текущей выполняемых подрограммах и состоит из стека объектов `Frame`. Объекты `Frame` на стеке однозначно отображаются на вызовы подпрограмм.

`Frame` содержит объект `code` и всю необходимую информацию, включя ссылка на локальное и глобальное пространство имён, необходимое для среды времени выполнения.

Для формирования стека вызовов объекты `Frame` ссылаются друг на друга. Каждый раз когда вызывается подпрограмма, создаётся объект `Frame`, добавляется к стеку и затем запускается объект `code` который он содержит.

Атрибуты объекта `Frame` только для чтения:

| Атрибут                           | Описание                                               |
| --------------------------------- | ------------------------------------------------------ |
| f_back                            | Предыдущий фрейм, или `None` если текущий фрейм нижний |
| f_code`    | Объект `code` фрейма |                                                        |
| f_locals                          | Словарь для поиска локальных переменных                |
| f_globals                         | Глобальные переменные                                  |
| f_builtins                        | Встроенные имена                                       |
| f_lasti                           |                                                        |

Атрибуты поддерживающие запись:

| Атрибут  | Описание                                                     |
| -------- | ------------------------------------------------------------ |
| f_trace  | Если не `None`, то функция отсюда будет вызвана в начале каждой строки кода |
| f_lineno | Номер текущей строки фрейма. Запись в этот метод позволяет перейти на данную строку кода. Работает только для самого верхнего фрейма. Отладчик может реализовать команду `jump` записывая в свойство `f_lineno` |

Объект `Frame` поддерживает один метод `feame.clear()` для очистки ссылок на локальные переменные. Если фрейм принадлежит генератору, то генератор финализируется. Этот метод помогает удалить циклические ссылки с участием объекта `Frame`. Если фрейм сейчас запущен то генерируется исключение `RuntimeError`. 

###### Объект Traceback

Объект `Traceback`представляют трассировку стека исключения. `Traceback` создаётся при возникновении исключения. Интерпретатор ищет обработчик исключения последовательно доставая фреймы выполнения (`Frame`) и вставляя новый объект `Traceback` перед текущим объектом `Traceback` для каждого диктуемого фрейма. Когда встречается обработчик исключения, трассировка стека становится доступны программе.

Объект `Traceback` доступен третьим элементом кортежа возвращаемым `sys.exc_info()`. Когда программа не содержит подходящего обработчик исключений, трассировка стека выводится в стандартный поток ошибок. Если интерпретатор запущен в интерактивном режиме, то последняя трассировка доступна через `sys.last_traceback`. Несколько важных атрибутов `Traceback` представлены в таблице:

| Метод     | Описание                                                     |
| --------- | ------------------------------------------------------------ |
| tb_next   | Следующий уровень в трассировке стека (по направлению к фрейму где произошло исключение). `None` если следующего уровня нет. |
| tb_frame  | Фрейм текущего уровня                                        |
| tb_lineno | Номер строки на которой возникло исключение                  |
| tb_lasti  | Указывает на точную инструкцию. Номер строки и последняя инструкция может отличаться от номера строки фрейма если исключение возникло в блоке `try` без подходящего обработчика или с `finally`. |

###### Объект Slice

Объект `Slice` представляет срез для метода `__getiter__()` последовательностей. Срезы используются для получения подпоследовательностей.

```python
t = [i for i in range(10)]

print(t) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(t[:10:2]) # [0, 2, 4, 6, 8]
```

They are also created by the built-in slice([start,], stop [,step]) function. The returned object
can be used in between the square brackets as a regular slice object.

Срез так же можно создать встроеннй функцией `slice([start,], stop [,step])`: 

```python
t = [i for i in range(10)]

print(t) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(t[:10:2]) # [0, 2, 4, 6, 8]

s = slice(None, 10, 2)
print(s) # slice(None, 10, 2)
print(t[s]) # [0, 2, 4, 6, 8]
```
Атрибуты объекта `Slice`:

| Атрибут | Описание                         |
| ------- | -------------------------------- |
| start   | Нижняя граница                   |
| stop    | Верхняя граница (необязательное) |
| step    | Величина шага (необязательное)   |

Каждый из необязательных аргументов равен `None` если пропущен. У среза есть несколько форм в дополнение к стандартной форме:

```python
# элементы начиная с start и заканчивая end-1
# эквивалентно slice(start, stop)
a[start:end] 

# элементы начиная с start и заканчивая последним индексом последовательности
# эквивалентно slice(start)
a[start:]

# элементы начиная с начала последовательности по end-1
# эквивалентно slice(None, end)
a[:end]

# поверхностная копия последовательности
# эквивалентно slice(None, None)
a[:]
```

Значения `start` и `end` могут быть отрицательными, что означает отчет с конца последовательности:

```python

# последния элемент последовательности
# эквивалентно slice(-1)
a[-1] 

# последние два элемента последовательности 
# эквивалентно slice(-2)
a[-2:]

# всё исключая два последних элемента последовательности 
# эквивалентно slice(None, -2)
a[:-2] 
```

Единственный метод `slice.indices(self, length)` принимает длину и возвращает кортеж из трёх чисел `(start, stop, step)`. Кортеж означает то как срез пименяется к данной длине.

```python
s = slice(10, 30, 1)

# применение slice(10, 30, 1) к последовательности длины 100 возвращает [10:30]
print(s.indices(100)) # (10, 30, 1)


# применение slice(10, 30, 1) к последовательности длины 15 возвращает [10:15]
print(s.indices(15)) # (10, 15, 1)


# применение slice(10, 30, 1) к последовательности длины 1 возвращает [1:1]
print(s.indices(1)) # (1, 1, 1)
print(s.indices(0)) # (0, 0, 1)
```

###### Объект `Generator`

Генераторы создаются при вызове функций генераторов (функции использующие ключеве слово `yield`). Этот тип обсуждается детальнее в главе Последовательности и генераторы.

После знакомства с иерархией встроенных типов, пришло время изучить глубже объектно-ориентированное программирование и способы создания своих иерархий и даже классов похожих похожих поведением на встроенные типы.


## 6. Объектно-ориентированное программирование

Классы это основа объектно-ориентированного программирования в Python и один из базовых способов организации кода в программе.

### 6.1 Механика определения классов

Оператор `class` описывает новый тип и определяет набор атрибутов, переменных и методов которые ассоциируются и разделяются между всеми объектами (экземплярами) этого класса. Определение простого класса:

```python
class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return self.balance
```

Оператор `class` определяет объекты классов, объекты экземпляров и объекты методов.

####  Объекты классов

Запуск оператора `class` создает объект класса. В начале запуска оператора `class` создаётся новое пространство имён в которое добавляются все атрибуты класса. В отличии от языков таких как Java, это пространтсов имен не создаёт новую локальную область видимости в методах класса, поэтому нужно исползовать полное имя при указании атрибутов класса.

Если в методе `__init__` вмето полного имени `Account.num_accounts` попытаться использовать `num_account` то будет сгенерировано исключение:

```python

class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return self.balance


acct = Account('obi', 10)

# Traceback (most recent call last):
#   File "test.py", line 23, in <module>
#     acct = Account('obi', 10)
#   File "test.py", line 8, in __init__
#     num_accounts += 1
# UnboundLocalError: local variable 'num_accounts' referenced before assignment
```

В конце выполнения оператора `class` создаётся объект класса. Область видимости предшествующая определению класса восстанавливается и объект класса становится доступным в ней под именем данным в заголовке определения класса.

Объект класса, как и любой другой объект Python, является экземпляром определённого класса. Класс для объектов классов называется `type`. 

```python
print(type(Account)) # <class 'type'>
```

Для того чтобы лучше понять что это означает, рассмотрим глубже последовательность действий при выполнении оператора `class`:

```python
class_name = "Account"
class_parents = (object,)
class_body = """
num_accounts = 0

def __init__(self, name, balance):
    self.name = name
    self.balance = balance
    num_accounts += 1

def del_account(self):
    Account.num_accounts -= 1

def deposit(self, amt):
    self.balance = self.balance + amt

def withdraw(self, amt):
    self.balance = self.balance - amt

def inquiry(self):
    return self.balance
"""

# новый словарь используется для локального пространства имён
class_dict = {}

# тело класса запускается с использованием словаря как локального пространства имён
exec(class_body, globals(), class_dict)

# словарь класса содержит связанные имена из тела класса
print(class_dict)
# {'num_accounts': 0, '__init__': <function __init__ at 0x036261D8>, 'del_account': <function del_account at 0x03626190>, 'deposit': <function deposit at 0x03626148>, 'withdraw': <function withdraw at 0x03626100>, 'inquiry': <function inquiry at 0x036260B8>}

# последний шаг создания класса
Account = type(class_name, class_parents, class_dict)

# рассмотрим созданный объект класса
print(Account) # <class '__main__.Account'>
print(type(Account)) # <type 'type'>
```

В течении выполнения оператора `class` интерпритатор выполняет следующую последовательность шагов (очень упрощенно):

1. Тело класса изолируется в объект `code`.
2. Создаётся словарь представляющй пространство имён для создаваемого класса.
3. Объект `code` представляющий тело класса запускается в пронстрансве имён.
4. В течении последнего шага, объект класса создаётся как экземпляр класса `type`, используя имя класса, родительский класс и словарь класса как аргументы. Класс `type` используемый для создания классов это мета-класс, класс классов. Мета-класс используемый при создании объекта класса может быть явно задан с помощью ключевого слова `metaclass` при определении класса. Если это слово не используется то базовые классы проверяются на использование мета-классов. Если базовые классы их не используют то применяется мета-класс по умочанию `type()`. Детальнее о мета-класса рассказано в последующих главах.

Объект класса поддерживает ссылки на атрибуты и создание объектов. На атрибуты ссылаются стандартным синтаксисом, через точку: имя объекта, затем точка, затем имя отрибута (`obj.name`). Все имена переменных и методов представленных в пространстве имён класса являются допустимыми именами атрибутов когда объекта класса создан.

```python
print(Account.num_accounts) # 0
print(Account.deposit) # <function Account.deposit at 0x00E46148>
```

Обекты создаются вызовом объекта класса, как обычной функции. Пераметры функции совпадают с параметрами метода `__init__`:

```python
>>> Account("obi", 0)
```

#### Объекты экземпляров

Объекты классов создают объекты экземпляры классов. Ссылки на атрибуты являются единственными возможными операциями для экземпляров объектов. Атрибуты делятся на два вида: атрибуты данных (переменные экземпляра) и атрибуты методов.

#### Объекты методов

Если `x` это экземпляр класса `Account`, то `x.deposit` это пример метода объекта. Метод объекта похож на функцию, однако в определение метода, включается дополнительный аргумент `self`.  Этот аргумент ссылается на экземпляр класса, но нам не требуется передавать его в явном виде:

```python
x = Account()
x.inquiry()
```

Вызов `x.inquiry()` эквивалентен вызову `Account.inquiry(x)`. Объект экземпляра `x` передаётся первым аргументом метода. Вызов метода объекта со списком аргументов эквивалентен вызову метода класса объекта с тем же список аугментов вместе с самим объектом переданным как первый аргумент. Методы хранятся просто как функции в словаре класса:

```python
print(type(Account.inquiry)) # <class 'function'>
```

Метод методы объектов это обёртка вокруг объектов функций. Когда вызывается метод объекта со списком аргументов, создаётся новый список аргументов вместе с экземпляром объекта. Исходный объект функции вызывается новым списком аргументов. Это применяется ко всем метода экземпляров объектов, включая метод `__init__`. 

Аргумент `self` не является зарезервированным словом, имя `self` просто принято в сообществе. Любое корректное имя аргумента может использоваться вместо него:

```python
class Account(object):
    num_accounts = 0

    def __init__(obj, name, balance):
        obj.name = name
        obj.balance = balance
        Account.num_accounts += 1

    def del_account(obj):
        Account.num_accounts -= 1

    def deposit(obj, amt):
        obj.balance = obj.balance + amt

    def withdraw(obj, amt):
        obj.balance = obj.balance - amt

    def inquiry(obj):
        return obj.balance


print(Account.num_accounts) # 0

x = Account('obi', 0)
x.deposit(10)
print(Account.inquiry(x)) # 10
```

Далее в этой главе будут описаны дескрипторы и алгоритм ссылок на атрибуты, которые позволят лучше понять эту трансформацию.

### 6.2 Настройка пользовательских типов

Python предоставляет широкие возможности настройки классов: доступ к атрибутам, создание классов, инициализация объектов и другие. Классы созданные пользователем могут обладать поведением похожим на встроенные типы и поддерживать операции `+`, `-`, `*`, `[]` и др.

Настройка классов возможна благодаря методам называемым магическими методами (magic methods) — это обычные методы Python имя которых начинается и заканчивается двойным подчёркиванием (`__`). Например, метод `__init__` вызываемый при инициализации экземпляра класса, или метод `__getitem__` вызываемый оператором `[]`: индекс `a[i]` преобразуется интерпретатором в вызов `type(a).__getitem__(a, i)`. Синтаксически всё это обычные методы, их можно объявлять стандартным образом в своих классах.

Рассмотрим магические методы.

#### Специальные методы для создания объектов

Методы `__new__` и `__init__` вызываются при создании объектов. Новый объект создаётся два этапа: первым вызывается статическим метод `__new__`возвращающий новый объект и затем вызывается метод `__init__` для инициализации созданного объекта переданными аргументами.

Особый случай когда нужно необходимо переопределять метод `__new__` это наследование встроенных неизменяемых типов. Любая инициализация в наследниках должна проходить до создания класса, так как значение неизменяемых классов не меняется после создания. Последующие изменения объекта, в том числе в методе `__init__`, не влияет на объект. Пример создания класса целых чисел которые округляет указанное значение до следующего целого:

```python
import math


class NextInteger(int):

     def __new__(cls, val):
         return int.__new__(cls, math.ceil(val))


print(NextInteger(2.2)) # 3
```

Попытка вызвать `math.ceil` в методе `__init__` приведет к сбою инициализации объекта.

Метод `__new__` может быть переопределён для создания класса синглтона (Singleton). Наследники этого класса смогут иметь только один экземпляр во время одного запуска программы. Следующий пример демонстрирует это: 

```python
class Singleton:
    def __new__(cls, *args, **kwds):
        it = cls.__dict__.get("__it__")

        if it is not None:
            return it

        cls.__it__ = it = object.__new__(cls)
        it.__init__(*args, **kwds)
        return it

    def __init__(self, *args, **kwsds):
        pass


class SingletonType1(Singleton):
    def __init__(self, msg):
        super().__init__()
        self.msg = msg


class SingletonType2(Singleton):
    def __init__(self, msg):
        super().__init__()
        self.msg = msg



s11 = SingletonType1('msg11')
s12 = SingletonType1('msg12')

s21 = SingletonType2('msg21')
s22 = SingletonType2('msg22')


print(f'{s11.msg}: {id(s11)}')
print(f'{s12.msg}: {id(s12)}')

print(f'{s21.msg}: {id(s21)}')
print(f'{s21.msg}: {id(s21)}')
```

```
msg12: 62616936
msg12: 62616936
msg22: 62617008
msg22: 62617008
```

Реализация метода `__new__` вызывает реализацию метода из базового класса `object.__new__(cls)`, которая возвращает объект.

Метод `__init__` переопределён чтобы выполнить инициализацию атрибутов экземпляра изменяемых типов.

#### Специальные методы для доступа к атрибутам

Методы этой категории предоставляют средства для работы со ссылками на атрибуты, например, для доступа или установки значения атрибута.

`__getattr__`

Этот метод применяется для обработки ситуации когда ссылка на атрибут не найдена ссылка на атрибут. Метод вызывается только если ссылка на атрибут не найдена в дереве классов объекта. Метод возвращает значение атрибута или генерирует исключение `AttributeError `. 

```python
class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def __getattr__(self, name):
        return "Hey I don't see any attribute called {}".format(name)

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)


x = Account('obi', 0)
print(x.balaance) # Hey I dont see any attribute called balaance
```

Будьте осторожны с реализацией `__getattr__`, если в методе будет ссылка на несуществующий атрибут то возникнет бесконечный цикл с вызовом метода `__getattr__`.


```python
class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def __getattr__(self, name):
        return self.namee # пробум доступ к несуществующей переменной

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)


x = Account('obi', 0)
print(x.balaance) # RecursionError: maximum recursion depth exceeded
```

`__getattribute__`

Этот метод реализуется для настройки доступа к атрибутам класса. Метод всегда вызывается во время доступа к атрибутам экземпляров класса.

`__setattr__`

Этот метод реализован для обработки присвоения атрибутам. В реализации метода необходимо использовать присвоение значений в словарь экземпляра вместо использования `self.name=value`. Обязательно необходимо вызывать метод базового класса с аналогичным именем:

```python
super().__setattr__(self, name, value)
```

`__delattr__`

Метод реализован для настройки удаления атрибутов экземпляра класса и вызывается при использовании `del obj.attr`.

`__dir__`

Метод реализован для настройки списка атрибутов объекта возвращаемых вызовом `dir(obj)`.

#### Методы эмуляции типов

Для работы со встроенными типами Python используются специальные операции. Например, числовые типы поддерживают оператор `+` для сложения двух чисел,оператор `-` для вычитания двух чисел, а типы последовательностей и словарей поддерживают  оператор `[]` для доступа к значениям. Последовательности так же поддерживают оператор `+` для соединения последовательностей. Пользовательские классы могут так же использовать эти операторы как и встроенные типы. Такое поведение реализуется через специальные методы которые вызываются при появлении специальных операторов. Эти методы можно сгруппировать на несколько типов которые мы разберем.

##### Методы числовых типов

Следующая таблица показывает базовые операции и специальные методы вызывающиеся когда появляются эти операторы:

| Метод                          | Оператор            |
| ------------------------------ | ------------------- |
| `a.__add__(self, b)`           | `a + b`             |
| `a.__sub__(self, b)`           | `a - b`             |
| `a.__mul__(self, b)`           | `a * b`             |
| `a.__truediv__(self, b)`       | `a / b`             |
| `a.__floordiv__(self, b)`      | `a // b`            |
| `a.__mod__(self, b)`           | `a % b`             |
| `a.__divmod__(self, b)`        | `divmod(a, a)`      |
| `a.__pow__(self, b[, modulo])` | `pow(a, b, modulo)` |

Python содержит концепцию отражённых операций (reflected operations), это описывалось в разделе про `NotImplemented` предыдущей главы. Ключевая идея этой концепции в том что если левый операнд бинарной арифметической операции не поддерживает требуемую операцию и возвращает `NotImplemented`, то производится попытка соответствующего вызова отраженной операции для правого операнда. Пример этого редко используемого функционала ниже:

```python
class MyNumber(object):
    def __init__(self, val):
        self.val = val

    def __str__(self):
        return str(self.val)


print((10 - MyNumber(9))) # TypeError: unsupported operand type(s) for -: 'int' and 'MyNumber'
```

В наследнике добавляем поддержку отраженной операции:

```python
class MyNumber(object):
    def __init__(self, val):
        self.val = val

    def __str__(self):
        return str(self.val)


class MyFixedNumber(MyNumber):
    def __rsub__(self, other):
        return MyNumber(other - self.val)


print((10 - MyFixedNumber(9)).val) # 1
```

Следующие методы реализуют отражённые бинарные арифметические операции:

| Метод                           | Оператор            |
| ------------------------------- | ------------------- |
| `a.__radd__(self, b)`           | `a + b`             |
| `a.__rsub__(self, b)`           | `a - b`             |
| `a.__rmul__(self, b)`           | `a * b`             |
| `a.__rtruediv__(self, b)`       | `a / b`             |
| `a.__rfloordiv__(self, b)`      | `a // b`            |
| `a.__rmod__(self, b)`           | `a % b`             |
| `a.__rdivmod__(self, b)`        | `divmod(a, a)`      |
| `a.__rpow__(self, b[, modulo])` | `pow(a, b, modulo)` |

Числовые типы поддерживают расширенные операторы присваивания:

```python
val = 10
val += 90
print(val) # 100
```

Список методов реализующих расширенные операции присваивания:

| Метод                      | Оператор       |
| -------------------------- | -------------- |
| `a.__iadd__(self, b)`      | `a += b`       |
| `a.__isub__(self, b)`      | `a -= b`       |
| `a.__imul__(self, b)`      | `a *= b`       |
| `a.__itruediv__(self, b)`  | `a /= b`       |
| `a.__ifloordiv__(self, b)` | `a //= b`      |
| `a.__imod__(self, b)`      | `a %= b`       |
| `a.__idivmod__(self, b)`   | `divmod(a, a)` |
| `a.__ipow__(self, b)`      | `a **= b`      |

##### Методы последовательностей и отображения

Последовательности и отображения часто называют контейнерами, потому что они содержат ссылки на другие объекты. Пользовательские типы могут эмулировать поведение контейнеров реализовав специальные методы.

`__len(obj)__`

Возвращает длину объекта. Метод вызывается из встроенной функции `len`.

Объект не реализующий метод `__bool()__` и возвращающий в методе `__len__()` ноль, рассматривается как `False` в контексте когда ожидается логический тип.

`__getitem__(obj, key)`

Возвращает элемент, вызывается оператором `obj[key]`. Для последовательностей `key` должен быть числом или объектом `slice`.  Если `key` неподходящего типа, должно быть сгенерировано исключение `TypeError`. Если `key` выходит за границы множества индексов последовательности, должно быть сгенерировано исключение `IndexError`.  Для отображений, если переданного ключа нет в контейнере то должно генерироваться исключение  `KeyError`.

`__setitem__(obj, key, value)`

Установка значения элемента`obj[key] = value`.

`__delitem__(obj, key)`

Вызывается командой `del obj[key]`.

`__contains__(obj, key)`

Возвращает `True` если `key` содержится в контейнере и `False` в противоположном случае. Вызывается командой `key in obj`.

`__iter__(self) `

Этот метод вызывается когда для контейнера требуется итератор. Метод должен возвращать объект итератора который может перебрать все объекты в контейнере. Для отображений объект должен перебирать ключи контейнера. Объект итератора так же должен реализовывать этот метод и возвращать себя. Метод используется в конструкции `for..in`.

Последовательности такие как списки дополнительно поддерживают сложение (для соединения списков) и умножение (для создания копий) с помощью методов: `__add__()`, `__radd__()`, `__iadd__()`, `__mul__()`, `__rmul__()` и `__imul__()`. 

Последовательности так же реализуют  метод`__reversed__()` используемый встроенной функцией `reversed()` для перебора объектов последовательности в обратном порядке.

Пользовательские классы могут реализовывать все эти специальные методы для получения требуемой функциональности.

##### Методы вызываемых типов

Callable types support the function call syntax, (args). Classes that implement the __call__(self[,
args...]) method are callable. User defined classes for which this functionality makes sense can
implement this method to make class instances callable. The following example shows a class
implementing the __call__(self[, args...]) method and how instances of this class can be called
using the function call syntax.

Вызываемые типы поддерживают синтаксис вызова функций `func(args)`. Классы реализующие метод `__call__(self[, args...])` являются вызываемыми, объекты этих классов можно вызывать как функцию. 

```python
class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def __call__(self, arg):
        return "I was called with \'{}\'".format(arg)

    def del_account(self):
        Account.num_accounts -= 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return self.balance


acct = Account('Ivan', 0)
print(acct("Testing function call on instance object")) # I was called with 'Testing function call on instance object

```

#### Специальные методы для сравнения объектов

Пользовательские классы могут поддерживать особую реализацию для специальных методов вызываемых операторами сравнения: <, >. <=, >=, ==. 

| Метод               | Оператор |
| ------------------- | -------- |
| `a.__lt__(self, b)` | `a < b`  |
| `a.__le__(self, b)` | `a <= b` |
| `a.__eq__(self, b)` | `a == b` |
| `a.__ne__(self, b)` | `a != b` |
| `a.__gt__(self, b)` | `a > b`  |
| `a.__ge__(self, b)` | `a >= b` |

В Python, если `x==y` равно `True` это не означает что `x != y` равно `False`, поэтому совместно с `__eq__()`  реализуется `__ne__()` для правильной работы всех операторов. Методы`__lt__()`, `__gt__()`, и `__le__()`, `__ge__()` являются отраженными операторами, в то же время `__eq__()` и `__ne__()` являются своим собственным отражением. Это означает что если при реализации любого из этих методов возвращается `NotImplemented` то используется соответствующий отраженный оператор.

#### Другие специальные методы

`__slots__()`

Это скорее специальный атрибут а не метод. Он используется для оптимизации, более эффективного хранение интерпретатором атрибутов объектов. По умолчанию объекты сохраняют свои атрибуты в словарь (атрибут `__dict__`) и это очень неэффективно если объект с несколькими атрибутами создаётся большое количество раз. `__slots__` статически резервирует место для атрибутов вместо динамического `__dict__`. 

```python
class Account:
    """base class for representing user accounts"""

    __slots__ = ['name', 'balance']
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def __getattr__(self, name):
        """Обрабатываем ссылки на несуществующие атрибуты"""
        return "Hey I dont see any attribute called {}".format(name)

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)


acct = Account("obi", 10)
print(acct.__dict__) # # Hey I dont see any attribute called __dict__

print(acct.__slots__)  # ['name', 'balance']

acct.x = 10 # AttributeError: 'Account' object has no attribute 'x'
```

Рассмотрим еще несколько вещей касающихся `__slots__`.

Если базовый класс содержит атрибут `__dict__` то использование `__slots__` в наследника бесполезно, словарь всё равно будет доступен.

Если используется `__slots__` и происходит попытка присвоения переменной не включенной в `__slots__` то генерируется исключение `AttributeError`, как показано в предыдущем примере.

Наследники будут содержать `__dict__` даже если они наследуются из класса со `__slots__`. Для того чтобы скрыть словарь наследники должны объявить свой собственный `__slots__` который будет содержать только дополнительные имена.

`__bool__`

Метод используется при преобразовании класса к логическому значению. Метод вызывается встроенной функцией `bool()` и должен возвращать `True` или `False`.  При отсутствии `__bool__` вызывается `__len__` и объект преобразовывается в `True` если метод возвращает значение отличное от нуля. Если не `__bool__`  не `__len__` не реализованы то все объекты рассматриваются как `True`.

`__repr__` и `__str__`

Эти методы возвращают строковое представление объекта. Методы используются в соответствующих встроенных функциях `repr()` и `str()`. 

Реализация `__repr__` должна возвращать как можно более недвусмысленное представление объекта. В идеале это будет строка запустив которую через `eval` будет создан исходный объект.

Реализация `__str__` должна возвращать удобное для человека представление объекта.

Рассмотрим пример с объектом даты и времени:

```python
import datetime

today = datetime.datetime.now()

print(str(today))
# '2015-07-05 20:55:58.642018'

print(repr(today))
# 'datetime.datetime(2015, 7, 5, 20, 55, 58, 642018)'
```

`__bytes__`

Метод вызывается встроенной функцией `bytes()` для преобразования объекта в бинарный (byte string) вид.

`__hash__`

Метод вызывается встроенной функцией `hash()`. Он также используется операциями над такими типами как `set`, `frozenset` и `dict` которые используют хеши объектов. Поддержка `__hash__` для пользовательских классов это сложное действие, как будет показано ниже. Встроенные неизменяемые классы являются хешируемыми, а изменяемые нет. Например, хешем числе является само число:

```python
print(hash(1)) # 1
print(hash(12345)) # 12345
```

По умолчанию хеш пользовательских классов равен их значению `id()`.  Реализация метода `__hash__()` должна возвращать число и равные объекты должны возвращать равное значение хеша: значение выражения `a==b and hash(a)==hash(b)` должно быть `True`. Правила реализации этого метода:

1. Класс должен определять метод `__hash__()` только если уже определён `__eq_()`.
2. Отсутствие реализации `__hash__()` делает класс нехешируемым.
3. Интерпретатор предоставляет пользовательским классам реализацию `__hash__()` и `__eq__()` по умолчанию: все объекты равны сами себе.
4. Переопределение метода `__eq__()` без определения метода `__hash__()` устанавливает `__hash__()` в значение `None`. Когда метод `__hash__()` равен `None`, экземпляр класса генерирует исключение при попытке получить значение хеша. Объект корректно идентифицируется как нехешируемый при проверке `isinstance(obj, collection.Hashable).
5. Если класс переопределяет `__eq__()` и необходимо сохранить реализацию `__hash__()` из базового класса, это может быть сделано присвоением `__hash__ = BaseClass.__hash__`.
6. Класс который не переопределяет `__eq__()` может подавить хеширование установкой `__hash__` в `None`. Если класс определит метод `__hash__()` который в явном виде генерирует исключение `TypeError`, экземпляры этого класса будут некорректно определятся хешируемыми командой `isinstance(obj, collections.Hashable)`.

### 6.3 Класс Vector

В этом разделе, полный пример использования специальных методов для подражания встроенным типам представлен классом `Vector`. Класс `Vector` поддерживает выполнение арифметических операций над векторами.

```python
# Copyright 2013 Philip N. Klein
class Vec:
    """
    A vector has two fields:
    D - the domain (a set)
    f - a dictionary mapping (some) domain elements to field elements
    elements of D not appearing in f are implicitly mapped to zero
    """

    def __init__(self, labels, function):
        assert isinstance(labels, set)
        assert isinstance(function, dict)
        self.D = labels
        self.f = function

    def __getitem__(self, key):
        """
        Return the value of entry k in v.
        Be sure getitem(v,k) returns 0 if k is not represented in v.f.
        >>> v = Vec({'a', 'b', 'c', 'd'},{'a':2, 'c':1, 'd':3})
        >>> v['d']
        3
        >>> v['b']
        0
        """
        assert key in self.D
        if key in self.f:
            return self.f[key]
        return 0

    def __setitem__(self, key, val):
        """
        Set the element of v with label d to be val.
        setitem(v,d,val) should set the value for key d even if d
        is not previously represented in v.f, and even if val is 0.
        >>> v = Vec({'a', 'b', 'c'}, {'b':0})
        >>> v['b'] = 5
        >>> v['b']
        5
        >>> v['a'] = 1
        >>> v['a']
        1
        >>> v['a'] = 0
        >>> v['a']
        0
        """
        assert key in self.D
        self.f[key] = val

    def __neg__(self):
        """
        Returns the negation of a vector.
        >>> u = Vec({1,3,5,7},{1:1,3:2,5:3,7:4})
        >>> -u
        Vec({1, 3, 5, 7},{1: -1, 3: -2, 5: -3, 7: -4})
        >>> u == Vec({1,3,5,7},{1:1,3:2,5:3,7:4})
        True
        >>> -Vec({'a','b','c'}, {'a':1}) == Vec({'a','b','c'}, {'a':-1})
        True
        """
        return Vec(self.D, {key: -self[key] for key in self.D})

    def __rmul__(self, alpha):
        """
        Returns the scalar-vector product alpha times v.
        >>> zero = Vec({'x','y','z','w'}, {})
        >>> u = Vec({'x','y','z','w'},{'x':1,'y':2,'z':3,'w':4})
        >>> 0*u == zero
        True
        >>> 1*u == u
        True
        >>> 0.5*u == Vec({'x','y','z','w'},{'x':0.5,'y':1,'z':1.5,'w':2})
        True
        >>> u == Vec({'x','y','z','w'},{'x':1,'y':2,'z':3,'w':4})
        True
        """
        return Vec(self.D, {key: alpha * self[key] for key in self.D})

    def __mul__(self, other):
        # If other is a vector, returns the dot product of self and other
        if isinstance(other, Vec):
            return dot(self, other)
        else:
            return NotImplemented  # Will cause other.__rmul__(self) to be invoked

    def __truediv__(self, other):  # Scalar division
        return (1 / other) * self

    def __add__(self, other):
        """
        Returns the sum of the two vectors.
        Make sure to add together values for all keys from u.f and v.f even if some keys in \
        u.f do not
        exist in v.f (or vice versa)
        >>> a = Vec({'a','e','i','o','u'}, {'a':0,'e':1,'i':2})
        >>> b = Vec({'a','e','i','o','u'}, {'o':4,'u':7})
        >>> c = Vec({'a','e','i','o','u'}, {'a':0,'e':1,'i':2,'o':4,'u':7})
        >>> a + b == c
        True
        >>> a == Vec({'a','e','i','o','u'}, {'a':0,'e':1,'i':2})
        True
        >>> b == Vec({'a','e','i','o','u'}, {'o':4,'u':7})
        True
        >>> d = Vec({'x','y','z'}, {'x':2,'y':1})
        >>> e = Vec({'x','y','z'}, {'z':4,'y':-1})
        >>> f = Vec({'x','y','z'}, {'x':2,'y':0,'z':4})
        >>> d + e == f
        True
        >>> d == Vec({'x','y','z'}, {'x':2,'y':1})
        True
        >>> e == Vec({'x','y','z'}, {'z':4,'y':-1})
        True
        >>> b + Vec({'a','e','i','o','u'}, {}) == b
        True
        """
        assert self.D == other.D
        return Vec(self.D, {key: self[key] + other[key] for key in self.D})

    def __radd__(self, other):
        """Hack to allow sum(...) to work with vectors"""
        if other == 0:
            return self

    def __sub__(a, b):
        """Returns a vector which is the difference of a and b."""
        return a + (-b)

    def __eq__(self, other):
        """
        Return true iff u is equal to v.
        Consider using brackets notation u[...] and v[...] in your procedure
        to access entries of the input vectors. This avoids some sparsity bugs.
        >>> Vec({'a', 'b', 'c'}, {'a':0}) == Vec({'a', 'b', 'c'}, {'b':0})
        True
        >>> Vec({'a', 'b', 'c'}, {'a': 0}) == Vec({'a', 'b', 'c'}, {})
        True
        >>> Vec({'a', 'b', 'c'}, {}) == Vec({'a', 'b', 'c'}, {'a': 0})
        True

        Be sure that equal(u, v) checks equalities for all keys from u.f and v.f even if
        some keys in u.f do not exist in v.f (or vice versa)
        >>> Vec({'x','y','z'},{'y':1,'x':2}) == Vec({'x','y','z'},{'y':1,'z':0})
        False
        >>> Vec({'a','b','c'}, {'a':0,'c':1}) == Vec({'a','b','c'}, {'a':0,'c':1,'b':4})
        False
        >>> Vec({'a','b','c'}, {'a':0,'c':1,'b':4}) == Vec({'a','b','c'}, {'a':0,'c':1})
        False

        The keys matter:
        >>> Vec({'a','b'},{'a':1}) == Vec({'a','b'},{'b':1})
        False

        The values matter:
        >>> Vec({'a','b'},{'a':1}) == Vec({'a','b'},{'a':2})
        False
        """
        assert self.D == other.D
        return all([self[key] == other[key] for key in self.D])

    def is_almost_zero(self):
        s = 0
        for x in self.f.values():
            if isinstance(x, int) or isinstance(x, float):
                s += x * x
            elif isinstance(x, complex):
                y = abs(x)
                s += y * y
            else: return False
        return s < 1e-20

    def __str__(v):
        "pretty-printing"
        D_list = sorted(v.D, key=repr)
        numdec = 3
        wd = dict([(k, (1 + max(len(str(k)), len('{0:.{1}G}'.format(v[k], numdec))))) if isinstance(v[k], int) or isinstance(v[k], float) else (k, (1 + max(len(str(k)), len(str(v[k])))))
        for k in D_list])
        s1 = ''.join(['{0:>{1}}'.format(str(k), wd[k]) for k in D_list])
        s2 = ''.join(['{0:>{1}.{2}G}'.format(v[k], wd[k], numdec) if isinstance(v[k], int) or \
                                                                 isinstance(v[k], float) else '{0:>{1}}'.format(v[k],
                                                                                                                wd[k])
                  for k in D_list])
        return "\n" + s1 + "\n" + '-' * sum(wd.values()) + "\n" + s2

    def __hash__(self):
        "Here we pretend Vecs are immutable so we can form sets of them"
        h = hash(frozenset(self.D))
        for k, v in sorted(self.f.items(), key=lambda x: repr(x[0])):
            if v != 0:
                h = hash((h, hash(v)))
        return h

    def __repr__(self):
        return "Vec(" + str(self.D) + "," + str(self.f) + ")"

    def copy(self):
        "Don't make a new copy of the domain D"
        return Vec(self.D, self.f.copy())

    def __iter__(self):
        raise TypeError('%r object is not iterable' % self.__class__.__name__)


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```
### 6.4 Наследование

Наследование &mdash; это механизм создания новых классов. Наследники специализируют или изменяют базовые классы добавляя в них новую функциональность. Python поддерживает множественное наследование как C++. Пример одиночного наследования в Python:

```python
class Account:
    """base class for representing user accounts"""
    num_accounts = 0


    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def __getattr__(self, name):
        """handle attribute reference for non-existent attribute"""
        return "Hey I dont see any attribute called {}".format(name)

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)

class SavingsAccount(Account):

    def __init__(self, name, balance, rate):
        super().__init__(name, balance)
        self.rate = rate

    def __repr__(self):
        return "SavingsAccount({}, {}, {})".format(self.name, self.balance, self.rate)
```

```python
>>>acct = SavingsAccount("Obi", 10, 1)
>>>repr(acct)
SavingsAccount(Obi, 10, 1)
```

#### Ключевое слово super 

В одиночной иерархии наследования `super` используется для ссылки на родительский класс без явного указания на него. Это похоже на метод `super` в Java. `super` применяется при переопределении метода, когда требуется вызвать родительскую версию переопределяемого метода. В примере выше, метод `__init__` в классе `SavingsAccount` переопределён, но с помощью `super` вызывается метод `__init__` родительского класса. При множественном наследовании `super` играет более важную роль.

#### Множественное наследование

В множественном наследовании класс может иметь несколько родительских классов. Одной из сложностей такого вида наследования является поиск нужной версии метода при его вызове. Представим что класс `D` наследник классов `B` и `C` и нужно вызывать метод родительского класса когда оба родителя имеют этот метод. В Python эта ситуация решается алгоритмом Method Resolution Order (MRO), он определяет как производится поиск метода в классе и всех базовых классах. Порядок методов вычисляется в момент определения класса и сохраняется в поле класса `__mro__`.

```python
>>> class A:
... def meth(self): return "A"
...
>>> class B(A):
... def meth(self): return "B"
...
>>> class C(A):
... def meth(self): return "C"
...
>>> class D(B, C):
... def meth(self): return "X"
...
```

```python
>>>
>>> D.__mro__
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
>>>
```

Алгоритм MRO состоит из двух шагов: поиск в глубину слева направо по всем классам в иерархии и удаление повторявшихся классов, кроме последнего вхождения.

В примере выше поиск в глубину по всем классам выдаёт такой список классов:

```python
[D, B, A, C, A, object]
```

Затем удаление повторяющихся классов, кроме последнего вхождения:

```python
[D, B, C, A, object]
```

Обратите внимание что если предок явно не задан, то класс наследуются от класса `object`.

#### Множественном наследование и super

Рассмотрим иерархию из прошлого примера. Класс `A` объявляет метод переопределяемый классами `B`, `C` и `D`. Предположим есть требование чтобы все методы вызывались, они сохраняют данные в каждом классе где объявлены, пропуск вызова приведёт к потере данных. Такое требование реализуется с помощью метода `super` и MRO:

```python
class A(object):
    
	def meth(self):
        "save A's data"
        print("saving A's data")

class B(A):
    
	def meth(self):
        "save B's data"
        super(B, self).meth()
        print("saving B's data")

class C(A):
    
	def meth(self):
        "save C's data"
        super(C, self).meth()
        print("saving C's data")

class D(B, C):

    def meth(self):
        "save D's data"
        super(D, self).meth()
        print("saving D's data")
```

Предположим метод `self.meth()` вызывается из экземпляра класса `D`. Тогда `super(D, self).meth()` найдёт и вызовет метод `B.meth(self)`, так как `B` первый базовый класс следующий за `D` в `D.__mro__` и `B` определяет метод `meth`.

Теперь `B.meth` вызывает `super(B, self).meth()` и так как `self` является экземпляром класса `D`, следующий класс после `B` это `C` (`D.__mro__ = [D, B, C, A]`) и поиск `meth` продолжается.

Следующим вызывается `C.meth`, который в свою очередь вызывает `super(C, self).meth()`.

Следующий после `C` класс в MRO это `A` и вызывается метод `A.meth`. Это исходное определение `meth`, поэтому вызов `super` не производится.

Используя `super` и MRO, интерпретатор находит и вызывает все версии метода `meth` реализованные в каждом класс иерархии.

Несмотря на всё сказанное, множественного наследования лучше избегать, потому, что для более сложных иерархий, вызовы могут быть намного сложнее чем в приведённых примерах.

### 6.5 Статичные и классовые методы

По умолчанию методы определённые в классе работают с экземплярами класса. Для определения статических и классовых методов применяются декораторы `@staticmethod` и `@classmethod`.

#### Статичные методы

Статичные методы это обычные функции внутри пространства имён класса. Ссылка на статичный метод из класса возвращает функцию вместо несвязанного метода:

```python
class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)

    @staticmethod
    def static_test_method():
        return "Current Account"
```

```python
>>> Account.static_test_method
<function Account.static_test_method at 0x101b846a8>
```

Декоратор `@staticmethod` используется для определения статического метода. Такой метод не требует аргумента `self`.

Статичные методы предоставляют механизм для организации кода. Метод связывается с классом и может быть переопределён в потомках.

В отличии от обычных методов, являющихся обёртками над функциями, статичные методы возвращают функцию без изменений.

#### Классовые методы

Классовые методы работают с классами вместо экземпляров классов. Классовый метод создаётся декоратором `@classmethod`. В первый аргумент такого метода передаётся ссылка на класс вместо экземпляра объекта:

```python
import json

class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)

    @classmethod
    def from_json(cls, params_json):
        params = json.loads(params_json)
        return cls(params.get("name"), params.get("balance"))

    @staticmethod
    def type():
        return "Current Account"
```

Пример использования классовых методов &mdash; фабрики для создания объектов. Представьте что данные для класса `Account` приходят в различных форматах: кортежи, JSON, строки. Возможности определить несколько методов `__init__` нет, поэтому классовые методы удобны для этой ситуации. Приведённый выше класс `Account` инициализируется строкой с JSON, для этого мы определили классовый метод `from_json` который принимает строку, извлекает параметры из JSON и создаёт объект используя извлечённые параметры.

Другой пример классового метода &mdash; [dict.fromkeys](https://docs.python.org/3/library/stdtypes.html#dict.fromkeys). Этот метод создаёт словарь из последовательности ключей и значений.

### 6.6 Дескрипторы и свойства

Дескрипторы являются эзотерической, но неотъемлемой частью Pyhon. Они широко используются в коде на Python и хорошее понимание дескрипторов даст более глубокое понимание языка. Рассмотрим три случая когда разработчики сталкиваются с дескрипторами.

**1**

Рассмотрим программу в которой нужно выполнять элементарную проверку типов данных аттрибутов объектов. Python это динамический язык и не поддерживает проверку типов, но это не мешает реализовывать проверку типов самостоятельно. Способ проверки типов атируботов может иметь следующую форму:

```pyton
    def __init__(self, name, age):
        
        if isinstance(name, str):
            self.name = name
        else:
            raise TypeError("Must be a string")
        
        if isinstance(age, int):
            self.age = age
        else:
            raise TypeError("Must be an int")
```

Этот метод метод может быть примене когда нужно проверить несколько атрибутов, но при увелечении их числа становится громоздким. Алтрернатива, ввести функцию `check(type, val)` и использовать её в методе `__init__()` перед присваиванием, но это не может быть элегантно применено для установки значений атрибутов после инициализации. Ещё одно быстрое решение —  использование геттера и сеттера, как в Java, но это не путь Python.

**2**

Рассмотрим программу в которой атрибуты объекта должны быть только для чтения после инициализации. Решение использующее специальные методы Python неуклюже и громоздко.

**3**

В конце, рассмотрим программу в которой доступ к атрибутам настраивается. Это может быть регистрация доступа к атрибуту или разные виды изинеения атрибута. Так же не сложно предстваить решение для этой задачи, но это решение будет неуклюжим и его не получится использовать повторно.

**4**

Все описанные задачи соединяются фактом что они все связаны со ссылками на атрибуты.

#### Введение в дескрипторы Python

Дескрипторы предоставляют элегантное, простое и надежное решение для всех описанных выше задач. Дескриптор — это объект представляющий значение атрибута. Это означает что если объект `account` содержит атрибут `name`, дескриптор это другой объект который может использоваться для представления значения содержащегося в атрибуте `name`. Объект дескриптора реализует специальные методы протокола дескрипторов: `__get__`, `__set__`, `__delete__`. Сигнатура каждого из этих методов показана ниже:

```python
descr.__get__(self, obj, type=None) --> value
descr.__set__(self, obj, value) --> None
descr.__delete__(self, obj) --> None
```

Объекты реализующие только метод `__get__` не являются дескрипторами данных, поэтому их можно только читать после инициализации. Объекты реализующие `__get__` и `__set__` являются дескрипторами данных, что означает что такие объекты доступны для записи.

Для лучшего понимания дескрипторов рассмотрим решение описанных в предыдущей секции проблем с помощью дескрипторов. Реализация проверки типов через дескрипторы является простой задачей:

```python
class TypedAttribute:
    def __init__(self, name, type, default=None):
        self.name = "_" + name
        self.type = type
        self.default = default if default else type()

    def __get__(self, instance, cls):
        return getattr(instance, self.name, self.default)

    def __set__(self, instance, value):
        if not isinstance(value, self.type):
            raise TypeError("Must be a %s" % self.type)
        setattr(instance, self.name, value)

    def __delete__(self, instance):
        raise AttributeError("Can't delete attribute")


class Account:
    name = TypedAttribute("name", str)
    balance = TypedAttribute("balance", int, 42)


acct = Account()
acct.name = "obi"
acct.balance = 1234

print(acct.balance) # 1234
print(acct.name) # obi
acct.balance = '1234' # TypeError: Must be a <class 'int'>
```

В этом примере, дескриптор `TypedAttrivute` принудительно производит элементарную проверку типа атрибута атрибута класса куда он добавлен. Важно отметить, что дескрипторы эффективны в случае если они объявлены на уровне класса (как в примере), а не на уровне экземпляра в `__init__`.

Дескрипторы являются неотъемлемой частью языка Python. Дескрипторы предоставляют механизм для свойств, статичных методов, классовых методов и других функций в классах Python. Дескриптор является первым типов объектов который ищется при использовании ссылки на атрибут. Когда на объекты ссылаются, ссылка `b.x` преобразуется в `type(b).__dict__['x'].__get__(b, type(b))`. 

Алгоритм поиска атрибута:

1. В `type(b).__dict__` ищется имя атрибута и если найден дескриптор данных, возвращается результат вызова метода `__get__` дескриптора. Если не найден, то производится поиск во всех базовых классах `type(b)` таким же способом.
2. Поиск в `b.__dict__` и если найдено имя атрибута, дескриптор возвращается.
3. Поиск в `type(b).__dict__` поиск дескриптора только для чтения, и если найден он возвращается.
4. Если имя атрибута не найдено, то генерируется исключение `AttributeError` или вызывается метод `__getattr()`.

Эта цепочка может быть переопределена определением пользовательского метода `__getattribute__`. Последовательность описанная выше содержится в метода `__getattribute__` по умолчанию.

Реализация решения для второй и третьей проблемы так же очень проста. Атрибут доступный только для чтения реализуется дескриптором только для чтения — дескриптором без метода `__set__`. Для добавления настраиваемого доступа к атрибутам, соответствующая функциональность добавляется в методы `__get__` и `__set__`.

#### Классовые свойства

Определение классов дескрипторов каждый раз когда нужен дескриптор громоздко. Свойства Python предоставляют удобный способ добавления дескрипторов данных к атрибутам. Сигнатура функции `property`:

```pythin
property(fget=None, fset=None, fdel=None, doc=None) -> property attribute 
```

`fget`, `fset`, и `fdel` это методы геттера, сеттера и deleter для атрибутов класса. Процесс создания свойств иллюстрируется следующим примером:

```python
class Accout(object):
    def __init__(self):
        self._acct_num = None

    def get_acct_num(self):
        return self._acct_num

    def set_acct_num(self, value):
        self._acct_num = value

    def del_acct_num(self):
        del self._acct_num

    acct_num = property(get_acct_num, set_acct_num, del_acct_num, "Account number property.")
```

Если `acct` это экземпляр `Account`, то `acct.acct_num` вызовет геттер, `acct.acct_num = value` вызовет сеттер и `del acct_num.acct_num` вызовет deleter.

Объект свойства и функционал который можно реализовать в Python иллюстрируется в [Descriptor How-To Guide](https://docs.python.org/3/howto/descriptor.html):

```python
class Property(object):
    "Emulate PyProperty_Type() in Objects/descrobject.c"

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
```

Python так же предоставляет декоратор`@property ` который используется для создания атрибутов только для чтения. Объект свойства содержит функции-декораторы `getter`, `setter` и `deleteter` которые используются для создания копии свойства с соответствующей функцией доступа установленной на декорируемую функцию. Это демонстрируется в следующем примере:

```python
class C(object):
    def __init__(self):
        self._x = None

    @property
    # x это свойство. декоратор создаёт свойство только для чтения
    def x(self):
        return self._x

    @x.setter
    # сеттер свойства x делает свойство записываемым
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x
```

Понимание дескрипторов улучшает наше понимание того что в действительности происходит в течении вызова метода. Заметьте что методы хранятся как обычный функции в словаре класса:

```python
>>>Account.inquiry
<function Account.inquiry at 0x101a3e598>
>>>
```

В тоже время, методы объекта имеют тип связанного метода:

```python
>>> x = Account("nkem", 10)
>>> x.inquiry
<bound method Account.inquiry of <Account object at 0x101a3c588>>
```

Для понимания как эта трансформация происходит, заметьте что связанные методы это просто обертка вокруг классовой функции. Функции это дескрипторы потому что они содержат метод `__get__` так что ссылка на функцию возвращает вызов метода `__get__` функции желаемого типа, саму функцию или связанный метод, в зависимости от того откуда ссылка — из класса или из экземпляра класса. Нетрудно представить как статичные или классовые методы могут быть реализованы дескриптором функции.

### 6.7 Абстрактные базовые классы

Чтобы классы реализовывали заданный набор методов в статически типизированных языках, таких как Java, используются интерфейсы и абстрактные классы.

Простая реализация такого контракта в Python &mdash; добавить в базовый класс методы по умолчанию, выбрасывающие исключение `NotImplementedError`. Такое решение неполное: наследники могут не переопределить все методы базового класса, а проблема обнаружится только во время выполнения программы.

Рассмотрим другую ситуацию &mdash; использование одного объекта для замещения другого. [Заместитель](https://ru.wikipedia.org/wiki/Заместитель_(шаблон_проектирования)) перехватывает все вызовы и передаёт их в скрываемый объект. Заместитель реализует все нужные методы, но проверку типа через `isinstance` он не проходит, так как имеет тип отличный от замещаемого объекта.

В Python такие задачи решаются через абстрактные базовые классы, реализуемые модулем `abc`. Этот модуль определяет мета-класс и набор декораторов. Для определения абстрактного базового класса мы устанавливаем `ABCMeta` как мета-класс абстрактного класса и помечаем декораторами `@abstractmethod` и `@abstractproperty` методы и свойства которые должны быть реализованы в неабстрактных потомках.

<!--more-->

Если потомки не реализуют абстрактные методы и свойства то не смогут создавать объекты:

```python
from abc import ABCMeta, abstractmethod

class Vehicle(object):
    
	__meta-class__ = ABCMeta
	
    @abstractmethod

    def change_gear(self):
        pass

    @abstractmethod
    def start_engine(self):
        pass

class Car(Vehicle):

    def __init__(self, make, model, color):
        self.make = make
        self.model = model
        self.color = color
```

```python
# abstract methods not implemented
>>> car = Car("Toyota", "Avensis", "silver")

Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: Can't instantiate abstract class Car with abstract methods change_gear, start_engine
```

Как только класс реализовал все абстрактные методы появляется возможность создавать объекты:

```python
from abc import ABCMeta, abstractmethod

class Vehicle(object):

    __meta-class__ = ABCMeta

    @abstractmethod
    def change_gear(self):
        pass

    @abstractmethod
    def start_engine(self):
        pass

class Car(Vehicle):
    
	def __init__(self, make, model, color):
        self.make = make
        self.model = model
        self.color = color

    def change_gear(self):
        print("Changing gear")

    def start_engine(self):
        print("Changing engine")
```

```python
>>> car = Car("Toyota", "Avensis", "silver")
>>> print(isinstance(car, Vehicle))
True
```

Абстрактные классы позволяет регистрировать существующие классы как часть своей иерархии, не проводя проверок на реализацию методов и свойств. Это простое решение второй проблемы открывающей параграф. Абстрактный класс регистрирует класс заместитель и проверка `isinstance` возвращает корректное значение:

```python
from abc import ABCMeta, abstractmethod

class Vehicle(object):

    __meta-class__ = ABCMeta

    @abstractmethod
    def change_gear(self):
        pass

    @abstractmethod
    def start_engine(self):
        pass

class Car(object):
    def __init__(self, make, model, color):
        self.make = make
        self.model = model
        self.color = color
```

```python
>>> Vehicle.register(Car)
>>> car = Car("Toyota", "Avensis", "silver")
>>> print(isinstance(car, Vehicle))
True
```

Абстрактные базовые классы широко используются в библиотеке Python. Они предоставляют средство для группировки классов, например, числовых типов, которые имеют относительно плоскую иерархию. Модуль `collections` также содержит абстрактные базовые классы для различных наборов операций с множествами, последовательностями и словарями. Абстрактные базовые классы Python предоставляют возможность применять контракты между классами такие же как интерфейсы в Java.

## 7. Функции

Функции это другой способ организации кода Python. Функции это именованный или анонимный набор операторов или выражений. В Python функции это объект первого класса. Это означает что нет ограничений на использование функции как значения: функции присваиваются переменным, функции передаются как аргумент в другие функции, функции возвращаются из метода или функции как любые другие значения Python такие как строка и число.

### 7.1 Определение функции

Ключевое слово **def** это обычный способ создания функции определённой пользователем. Определение функции является исполняемым оператором.

```python
def square(x):
    return x**2
```

Когда встречается определение функции, такое как определение функции `square` выше, запускается только определение функции `def square(x)`, это означает что все аргументы вычисляются. Вычисление аргументов имеет несколько следствий для аргументов со значениями по умолчанию в виде изменяемых типов данных, мы рассмотрим это дальше в этой главе. Исполнение определения функции связывает имя функции в текущем пространстве имён с объектом функции который является обёрткой над исполняемым кодом функции. Объект функции содержит ссылку на текущее глобальное пространство имён которое используется когда вызывается функция. Определение функции не запускает тело функции, оно запускается только при вызове функции.

Python поддерживает анонимные функции. Эти функции создаютсся с использованием ключевого слова **lambda**:

```python
lambda_expr ::= "lambda" [parameter_list]: expression
```

Лямбда-выражение, после выполнения, возвращает объект функции с такими же атрибутами как и именованной функции. Лямбда-выражение обычно используется только для очень простых функций, так как оно содержит только одно выражение. Лямбда-выражение для функции `square` представлено ниже:

```python
>>> square = lambda x: x**2
>>> for i in range(10):
        square(i)
0
1
4
9
16
25
36
49
64
81
>>>
```

### 7.2 Функции это объекты

Функции, как и другие значения, это объекты. Функции имеют тип `function`.

```python
def square(x):
    return x*x

print(type(square)) # <class 'function'>
```

Как и другие объекты, анализ функции через `dir()` предоставляет список атрибутов функции:

```python
def square(x):
    return x**2

print(square) # <function square at 0x031AA230>

print(dir(square))
# ['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
```



Рассмотрим важные атрибуты функций.

`__annotations__`

Этот атрибут содержит мета-информацию об аргументах и возвращаемом типе из определения функции. Python3  предоставляет необязательную функциональность для аннотации функций в основном для помощи инструментам используемым для разработки приложений на Python. Пример аннотации функции:

```python
def square(x: int) -> int:
    return x*x

print(square.__annotations__) # {'x': <class 'int'>, 'return': <class 'int'>}
```

Параметры аннотируются двоеточием после имени параметра, следующее за ним выражение вычисляется в значение аннотации. Возвращаемое значение аннотируется литералом `->` и следующим за ним выражением между списком параметров и двоеточием обозначающим конец инструкции **def**. В случае значений по умолчанию для функций, аннотация имеет следующую форму:

```python
def def_annotation(x: int, y: str = "obi"):
    pass
```

`__doc__`

Возвращает строку документации данной функции.

```python
def square(x):
    """return square of given number"""
    return x**2

print(square.__doc__) # 'return square of given number'
```

`__name__`

Возвращает имя функции.

```python
def square(x):
    """return square of given number"""
    return x**2

print(square.__name__) # square
```

`__module__` 

Возвращает имя модуля в котором определена функция.

```python
print(square.__module__) # __main__
```

`__defaults__` 

Возвращает кортеж значений по умолчанию аргументов. 

`__kwdefaults__`

Возвращает словарь содержащий значения по умолчанию ключевых аргументов.
`__globals__`

Возвращает ссылку на словарь, который содержит глобальные переменные функции. (смотрите главу 5 о глобальных переменных).

```python
print(square.__globals__)
# {'__builtins__': <module '__builtin__' (built-in)>, '__name__': '__main__', 'square': <function square at 0x10f099c08>, '__doc__': None, '__package__': None}
```

`__dict__`

Возвращает пространство имён произвольных атрибутов функции.

```python
print(square.__dict__) # {}
```

`__closure__`

Возвращает кортеж ячеек содержащий привязки свободных переменных функции. Замыкания обсуждаются позже в этой главе.

---

Функции могут передаваться как аргумент в другие функции. Функции принимающие другие функции как аргумент обычно называются **функциями высшего порядка** и это важная часть **функционального программирования**. Очень хороший пример функции высшего порядка это функция [**map**](https://docs.python.org/3.9/library/functions.html#map) которая принимает функцию и прибираемый объект, применяет функцию к каждому элементу из перебираемого объекта и возвращает новый список. Пример использования `map` с функцией `square`:

```python
>>> map(square, range(10))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

Функция может быть объявлена внутри другой функции и возвращена после вызова функции.

```python
def make_counter():
    count = 0

    def counter():
        nonlocal count # nonlocal захыватывает привязку count из внешнего пространства имён, не из глобального
        count += 1
        return count

    return counter

func = make_counter()

print(func) # <function make_counter.<locals>.counter at 0x02D2B7C0>

print(func()) # 1
print(func()) # 2
```

В этом примере, функция `counter` определена внутри другой функции `make_counter` и функция `counter` возвращается каждый раз при запуске `make_counter`.

Функция, возвращаемую `make_counter`, присваивается переменной `func`. Переменная ссылается на объект функции и вызывается точно так же как и любая другая функция.

### 7.3 Функции это дескрипторы

Как и обсуждалось в предыдущей главе, функции так же являются дескриптором. Исследование атрибутов функции показывает что функция содержит атрибут `__get__`, что делает функцию дескриптором только для чтения (non-data descriptor).

```python
def square(x):
    return x**2

print(dir(square))
# ['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
```

Метод `__get__` вызывается каждый раз когда ссылаются на функцию и предоставляет механизм для обработки вызова метода из объекта или обычного вызова функции. Эта характеристика функции позволяет функции возвращать себя или связанный метод в зависимости от того где и как происходит ссылка на функцию.

### 7.4 Вызов функций

In addition to calling functions in the conventional way with normal arguments, Python also
supports functions with variable number of arguments. These variable number of arguments come
in three flavours that are described below:

В дополнение к вызову функций обычным способом с нормальными аргументами, Python поддерживает функции с переменным количеством аргументов. Переменное количество аргументов доступно в трёх вариантах описанных далее.

#### Значения аргументов по умолчанию

Если все или некоторые из аргументов функции имеют значения по умолчанию, то функция может быть вызвана с несколькими аргументами, а для остальных будут использоваться значения по умолчанию.

```python
def show_args(arg, def_arg = 1, def_arg2 = 2):
   return "arg = {}, def_arg = {}, def_arg2 = {}".format(arg, def_arg, def_arg2)
```

Функция `show_args` определена с одним нормальным позиционным аргументом `arg` и двумя аргументами со значениями по умолчанию: `def_arg` и `def_arg2`. Функция может быть вызвана любым из следующих способов:

**1**

На вход функции подаются только значения для позиционных аргументов без значений по умолчанию. Оставшиеся аргументы принимают значения по умолчанию.

```python
def show_args(arg, def_arg = 1, def_arg2 = 2):
   return "arg = {}, def_arg = {}, def_arg2 = {}".format(arg, def_arg, def_arg2)


print(show_args("tranquility"))
# arg = tranquility, def_arg = 1, def_arg2 = 2
```

**2**

На вход функции подаётся несколько аргументов переопределяющих значения аргументов по умолчанию:

```python
def show_args(arg, def_arg = 1, def_arg2 = 2):
   return "arg = {}, def_arg = {}, def_arg2 = {}".format(arg, def_arg, def_arg2)


print(show_args("tranquility", "to Houston"))
# arg = tranquility, def_arg = to Houston, def_arg2 = 2
```

**3**

На выход функции подаются все аргументы:

```python
def show_args(arg, def_arg = 1, def_arg2 = 2):
   return "arg = {}, def_arg = {}, def_arg2 = {}".format(arg, def_arg, def_arg2)


print(show_args("tranquility", "to Houston", "the eagle has landed"))
# arg = tranquility, def_arg = to Houston, def_arg2 = the eagle has landed
```

---

Очень важно осторожно использовать изменяемые структуры данных в качестве значений аргументов по умолчанию. Определение функции запускается только один раз поэтому изменяемые структуры данных создаются один раз во время определения функции. Это означает что одна и та же измененяемая структура данных используется для всех вызовов функций:

```python
def show_args_using_mutable_defaults(arg, def_arg = []):
    def_arg.append("Hello World")
    return "arg={}, def_arg={}".format(arg, def_arg)

print(show_args_using_mutable_defaults("test"))
# "arg=test, def_arg=['Hello World']"

print(show_args_using_mutable_defaults("test 2"))
# "arg=test 2, def_arg=['Hello World', 'Hello World']"
```

При каждом вызове функции, строка `Hello World` добавляется в список `def_arg` и после двух вызовов функции аргумент по умолчанию содержит две строки `Hello Wordl`. 

#### Именованные аргументы

Функцию можно вызвать с использованием именованных аргументов в формате `kwarg=value`. `kwarg` ссылается на имя аргумента использованное при определении функции.  Рассмотрим функцию с одним позиционным аргументом без значения по умолчанию и одним аргументом со значением по умолчанию:

```python
def show_args(arg, def_arg = 1):
    return "arg = {}, def_arg = {}".format(arg, def_arg)


test = 42
```

Эта функция может быть вызвана любым из следующих способов:

```python
test = 42

show_args(arg = "test", def_arg = 3)
show_args(test)
show_args(arg = "test")
show_args("test", 3)
```

При вызове функции именованные аргументы не должны появляться раньше не именованных, такой вызов функции не сработает:

```python
show_args(def_arg = 4)
```

Функции не поддерживают дублирование подстановки значения в один аргумент, следующий вызов неверен:

```python
show_args("test", arg="testing")
```

В примере выше, аргумент `arg` это позиционный аргумент, поэтому ему присевается значение `test`. Попытка присвоения именованному аргументу `arg` снова является попыткой множественного присвоения и она не удастся.

Все именованные аргументы должны соответствовать одному из аргументов описанных в определении функции. Порядок именованных аргументов включая обязательные и необязательные аргументы неважен. Следующий вызов функции корректен:

```python
show_args(def_arg = "testing", arg = "test")
```

#### Список произвольных аргументов

Python позволяет опередить функцию с переменным количеством аргументов которые передаются в функцию в виде кортежа:

```python
def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))
```

Произвольные аргументы должны идти за обычными аргументами, в этом примере, за аргументами`file` и `separator`. Пример вызова такой функции:

```python
f = open("test.txt", "wb")
write_multiple_items(f, " ", "one", "two", "three")
```

Аргументы `one`, `two`, `three` соединяются в кортеж который доступен через периметр `args`. 

#### Распаковка аргументов функции

Иногда, аргументы для функции уже находятся в кортеже, списке или словаре. В этом случае аргументы можно распаковать в функцию с помощью операторов `*` и `**`. Рассмотрим следующую функцию с двумя позиционными аргументами:

```python
def print_args(a, b):
    print(a)
    print(b)
```

Если аргументы для вызова функции находятся в списке, то они распаковываются следующим способом:

```python
args = [1, 2]
print_args(*args)
# 1
# 2
```

Словари распаковываются оператором `**`. Значения словаря подставляются в именованные аргументы:

```python

def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn’t", action)
    print("if you put", voltage, "volts through it.")
    print("E’s", state, "!")


d = {"voltage": "four million", "state": "bleedin’ demised", "action": "VOOM"}
parrot(**d)
# -- This parrot wouldn’t VOOM
# if you put four million volts through it.
# E’s bleedin’ demised !
```

#### Параметры функции * и **

Sometimes, when defining a function, it is not known before hand the number of arguments to
expect. This leads to function definitions of the following signature:

Иногда при определении функции неизвестно заранее какое ожидать количество аргументов. Это приводит к следующему определению функции:

```python
show_args(arg, *args, **kwargs)
```

Аргумент `*args` представляет неизвестной длины последовательность позиционных аргументов. Аргумент `**kwargs` представляет словарь именованных аргументов. Аргумент `*args` должен идти раньше аргумента `**kwargs` в определении функции.

```python
def show_args(arg, *args, **kwargs):
    print(arg)
    for item in args:
        print(item)
    for key, value in kwargs.items():
        print(key, value)


args = [1, 2, 3, 4]
kwargs = dict(name='testing', age=24, year=2014)
show_args("hey", *args, **kwargs)

# hey
# 1
# 2
# 3
# 4
# name testing
# age 24
# year 2014
```

Аргументы `*args` и `**kwargs` не обязательны:

```python
show_args("hey") 
# hey
```

Такое тип определения функции играет большую роль в декораторах которые мы рассмотрим в следующей главе.

### 7.5 Вложенные функции и замыкания

Определение функции внутри другой функции создаёт вложенную функцию:

```python
def make_counter():
    count = 0

    def counter():
        nonlocal count 
        # nonlocal завхывает привязыке count из внешнего не глобального пространства имён
        count += 1
        return count
    return counter
```

Вложенная функция `counter` находится в пространстве имён внутри функции `make_counter` поэтому для использования `counter` снаружи её нужно вернуть из `make_counter`.

При каждом вызовtе `make_counter` создаётся новый экземпляр вложенной функции `counter`. При создании экземпляра каждый раз выполняется определение функции `counter`, но не её тело.

Вложенная функция имеет доступ к окружению в котором создавалась. Внутренняя функция `counter`, продолжает ссылаться на переменную определённую снаружи, во внешней функции `make_counter`,  даже после того как функция `make_counter` завершилась.

```python
x = make_counter()

print(x) # <function make_counter.<locals>.counter at 0x0124B7C0>
print(x()) # 1
```

Когда вложенная функция ссылается на переменные из внешней функции в которой они определены, говорят что вложенная функция это замыканием над этими переменными. Специальный атрибут функции `__closure__` используется для доступа к переменным в замыкании.

```python
cl = x.__closure__
print(cl) # (<cell at 0x03A2E130: int object at 0x5183E7B0>,)
print(cl[0].cell_contents) # 1
```

В предыдущих версиях Python (Python 2.*)  переменные неизменяемых типов, такие как строки и числа, нельзя было обернуть в замыкание:

```python
def counter():
    count = 0

    def c():
        count += 1
        return count
    return c

c = counter()
c() # UnboundLocalError: local variable 'count' referenced before assignment
```

В таких ситуациях использовали изменяемые тип:

```python
def counter():
    count = [0]

    def c():
        count[0] += 1
        return count[0]
    return c


c = counter()
print(c()) # 1
print(c()) # 2
print(c()) # 3
```

Python 3 предоставляет ключевое слово `nonlocal` для решения этой проблемы:

```python
def counter():
    count = 0
    def c():
        nonlocal count
        count += 1
        return count
    return c
```

Замыкания используются для поддержания состояния и в некоторых простых случаях предоставляют более простое и читаемое решение чем классы. Рассмотрим реализацию API для логирования через классы:

```python

class Log:
    def __init__(self, level):
        self._level = level

    def __call__(self, message):
        print("{}: {}".format(self._level, message))


log_info = Log("info")
log_warning = Log("warning")
log_error = Log("error")
```

Тот же функционал реализованный через замыкание:

```python
def make_log(level):
    def _(message):
        print("{}: {}".format(level, message))
    return _


log_info = make_log("info")
log_warning = make_log("warning")
log_error = make_log("error")
```

Замыкания играют основную роль в декораторах функций. Детальнее это рассмотрено в главе про метапрограммирование. Также замыкания являются основной для частичных функций описанных в следующей главе.

### 7.6 Введение в функциональное программирование

#### Основы

Отличительный признак функционального программирования в отсутствии побочных эффектов в коде. В сущности это означает что в функциональном программировании значения объектов не изменяются после создания и при изменении создаётся новый объект с изменённым значением. Пример функции с побочным эффектом, аргумент переданный в функцию изменяется: 

```python
def squares(numbers):
    for i, v in enumerate(numbers):
        numbers[i] = v**2
    return numbers
```

Функциональная версия функция без изменения аргумента:

```python
def squares(numbers):
    return map(lambda x : x * x, numbers)
```

Так как я языке функции являются объектами первого класса становится возможным применять техники функционального программирования такие как маппинг (mapping), свёртку (reducing), фильтрацию (filtering), карринг (currying) и рекурсию. В примере выше, функция `map` применяет лямбда-выражение `x : x * x` к каждому элементу переданной последовательности чисел.

Python предоставляет встроенные функции, такие как `map`, `filter` и `reduce` помогающие в функциональном программировании.

**map(func, iterable)**

Это классическая конструкция функционального программирования которая берет функцию и перебираемый объект как аргументы и возвращает итератор который применяет функции к каждому элементу перебираемого объекта. Функция `square` в последнем примере демонстрирует применение функции `map`. 

Идеи конструкций `map` и `reduce` применяются в популярной модели обработки больших данных MapReduce. Она использует для разделения (map) операций на потоки кластеров распределённых машин и затем сборку и вычисление конечного результата (reduce).

**filter(func, iterable)**

Функция `filter` принимает на вход функцию и перебираемый объект в виде аргументов. Затем применяет функцию к каждому элементу перебираемого объекта и возвращает итератор перебирающий элементы для которых функция вернула `True`.

```python
even = lambda x: x % 2 == 0

print(even(10)) # True

print(filter(even, range(10))) # <filter object at 0x036EE1C0>

print(list(filter(even, range(10)))) # [0, 2, 4, 6, 8]
```

**reduce(func, iterable[, initializer])**

Эта функция находятся в модуле `functools`. Функция `reduce` применяет функцию-аргумент `func` кумулятивно к каждому элементу перебираемого объекта `iterable` и возвращает единичное значение. Функция `func` должна принимать два позиционных аргумента.

```python
from functools import reduce

value = reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])
# вычиляется так ((((1+2)+3)+4)+5)

print(value) # 15
```

Свёртка начинается с первых двух элементов из `iterable`, затем результат используется совместно с третьим элементом и т. д. Если заполнен аргумент `initializer` то он служит начальным элементом.

Пример соединения вложенных списков:

```python
import functools


def flatten_list(nested_list):
    return functools.reduce(lambda x, y: x + y, nested_list, [])


print(flatten_list([[1, 3, 4], [5, 6, 7], [8, 9, 10]]))
# [1, 3, 4, 5, 6, 7, 8, 9, 10]
```

Некоторая функциональность описанных выше встроенных функций может замена использованием более распроданных конструкций. Генераторы списков это одна одна из самых распространённых альтернатив этим функциям.

#### Сomprehensions

Специальный конструкции Python, называемые comprehensions, позволяют строить последовательности из других последовательностей. Есть три типа таких конструкций:

1. Генераторы списков (List Comprehensions)
2. Генераторы множеств (Set Comprehensions)
3. Генераторы словарей (Dictionary Comprehensions)

##### Генераторы списков

Генераторы списков позволяют конструировать списки из любых перебираемых объектов. Список квадратов последовательности чисел можно вычислить функцией `map`:

```python
def squares(numbers):
    return list(map(lambda x : x * x, numbers))
```

Такой же список созданный генератором списков:

```python
squares = [x ** 2 for x in range(10)]
```

Эта версия более лаконичная и читабельная.

Генератор списка состоит из квадратных скобок содержащих выражение за которым следуют выражения **for** и **if**. Выражений **for** может быть несколько.

```python
[expression for item1 in iterable1 if condition1
            for item2 in iterable2 if condition2
            ...
            for itemN in iterableN if conditionN ]
```

Результатом генератора списков является новый список. Список формируется вычислением выражений в контексте предложений **for** и **if**.

Пример создания списка квадратов чётных чисел между 0 и 10:

```python
even_squares = [i ** 2 for i in range(10) if i % 2 == 0]

print(even_squares)
# [0, 4, 16, 36, 64]
```

Выражение `i ** 2` вычисляется в контексте предложения **for** которое перебирает числа от 0 до 10. Предложение **if** фильтрует нечётные числа.

##### Вложенный цикл for и генератор списков

Генераторы списков могут использоваться с несколькими или вложенными списками. Рассмотрим пример, простой фрагмент кода показанный ниже создаёт кортеж из пары чисел используя две данные последовательности:

```python
combs = []

for x in [1, 2, 3]:
    for y in [3, 1, 4]:
        if x != y:
            combs.append((x, y))

print(combs)
# [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

Тот же функционал с использованием генератора списка:

```python
>>> [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

Обратите внимание, что последовательность **for** в генераторе списка совпадает с последовательностью **for** в обычных циклах. 

##### Вложенные генераторы списков

Генераторы списков могут быть вложенные. Рассмотрим пример из [документации Python](https://docs.python.org/3.9/tutorial/datastructures.html) для создания вложенного списка:

```python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]
```

Транспонирование это операция которая создаёт новую матрицу в которой строки являются колонками исходной матрицы, а колонки новой матрицы являются строками старой матрицы. Реализация транспонирования матрицы через вложенный генератор списка:

```python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]

transposed =  [[row[i] for row in matrix] for i in range(4)]

print(transposed)
# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

Код выше эквивалентен следующему:

```python
transposed = []
for i in range(4):
    transposed.append([row[i] for row in matrix])

print(transposed)
# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

##### Генераторы множеств

В генераторах множеств вместо квадратных скобок используются фигурные:

```python
x = {i ** 2 for i in range(10)}

print(x)
# {0, 1, 64, 4, 36, 9, 16, 49, 81, 25}
```

##### Генераторы словарей

Фигурные скобки так же используются в генераторах словарей. Следующий пример демонстрирует отображение чисел на их квадраты, созданное через генератор словаря:

```python
x = {i : i ** 2 for i in range(10)}

print(x)
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
```

#### Модуль functools

Модуль `functools` содержит функции высшего порядка которые получают и возвращают другие функции. Рассмотрим несколько функций из этого модуля.

`partial(func, *args, **keywords)`

Функция `partical` возвращает объект, которым может быть вызван как исходная функция `func` с уже подставленными аргументами `*arg` и `**keywords`. Если в эту новую функцию передать те же параметры, то они переопределят параметры установленные `partial`:

```python
from functools import partial

basetwo = partial(int, base=2)
basetwo.__doc__ = 'Convert base 2 string to an int.'

print(basetwo('10010')) # 18
print(basetwo('10010', base = 10)) # 10010
```

В этом примере, новый вызываемый объект `baseto` принимает число в бинарном виде и конвертирует в десятичное число. Исходная функция `int()`, принимающая два аргумента, оказалась обёрнута в новую функцию принимающую один аргумент.

Для лучшего понимания рассмотрим возможный способ реализации функции `partial`:

```python
def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*(args + fargs), **newkeywords)

    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
```

Функция `partial` предоставляет элегантное решение практических проблем встречающихся при разработке. Представим что имеется список точек представленных в виде кортежа координат `(x, y)` и есть требование отсортировать эти точки в соответствии с их расстоянием до другой центральной точки. Следующая функция вычисляет дистанцию между двумя точкам:

```python
import math

points = [(1, 2), (3, 4), (5, 6), (7, 8)]


def distance(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    return math.hypot(x2 - x1, y2 - y1)
```

Встроенный методы списков `sort()` поддерживает аргумент `key` для настройки порядка сортировки, но он работает с функцией принимающей один аргумент, так что функция `distance()` не подойдёт. Метод `partial` даёт решение этой проблемы:

```python
pt = (4, 3)
points.sort(key=functools.partial(distance, pt))

print(points)
# [(3, 4), (1, 2), (5, 6), (7, 8)]
```

Функция `partial` создаёт и возвращает вызываемый объект принимающий один аргумент — точку. Одновременно `partial` захватывает ссылку на точку `pt` и передаёт её в `distance()`. В итоге сортировка получает функцию которая принимает одну точку и вычисляет её расстояние до другой заданной ранее точки.

`@functools.lru_cache(maxsize=128, typed=False)`

После оборачивания функции этим декоратором, функция запоминает `maxsize` последних вызовов. При последующем вызове, если аргументы функции совпадают с теми что передавались ранее, то сразу возвращается закешированный результат. Когда достигнут `maxsize` самые старые значения удаляются. Декоратор использует словарь для кеширования, так что аргументы функции должны быть хешируемыми. Декоратор `lru_cache` предоставляет функцию `cache_info` для получения информации об использовании кеша.

`@functools.singledispatch`

Этот декоратор модифицирует функции в обобщённую функцию. У функции появляется возможность динамически обрабатывать перегрузку — одна функция может обрабатывать разные типы данных. Механизм демонстрируется в следующем примере:

```python
from functools import singledispatch 


@singledispatch
def fun(arg, verbose=False):
    if verbose:
        print("Let me just say,", end=" ")
    print(arg)


@fun.register(int)
def _(arg, verbose=False):
    if verbose:
        print("Strength in numbers, eh?", end=" ")
    print(arg)


@fun.register(list)
def _(arg, verbose=False):
    if verbose:
        print("Enumerate this:")
    for i, elem in enumerate(arg):
        print(i, elem)


fun("Hello, world.")
# Hello, world.

fun(1, verbose=True)
# Strength in numbers, eh? 1

fun([1, 2, 3], verbose=True)
# Enumerate this:
# 0 1
# 1 2
# 2 3

fun((1, 2, 3), verbose=True)
# Let me just say, (1, 2, 3)
```

Обобщённая функция определяется декоратором `@singledispatch`. Декоратор @register` используется для определения функций для каждого обрабатываемого типа. Выбор корректной функции базируется на типе первого аргумента при вызове функции, соответственно с именем декоратора (single — одиночный).

В случае подходящей под передаваемый тип данных функции не зарегистрировано, то вызывается базовая обобщённая функция — та что обёрнута декоратором `@singledispatch`.

#### Последовательности и функциональное программирование

Последовательности такие как списки и кортежи играют центральную роль в функциональном программировании. Книга Структура и интерпретация компьютерных программ, одна из великих книг computer science когда либо написанных, посвящает почти целую главу дискуссии о последовательностях и их обработке. Важность последовательностей видна по их вездесущности языке. Встроенные функции, такие как `map` и `filter` принимают и производят последовательности. Другие встроенные функции, такие как `min`, `max`, `reduce`, принимают последовательность и возвращают значения. Функции вроде `range`, `dict.items()` производят последовательности.

Вездесущность последовательностей требует чтобы они были реализованы эффективно. Существует несколько способов их реализации. Простой способ предполагает хранить все элементы последовательности в памяти. Это ограничивает длину последовательности оперативной памятью машины. Более умное решение представлять последовательность в виде одного объекта. Этот объект знает как вычислить следующий элемент последовательности и делает это когда необходимо. Python содержит встроенный протокол `__iter__` для реализации такого объекта. Похожее поведение реализуется генераторами — блистательной возможностью языка. Обе эти возможности рассмотрены в следующей главе.

## 8. Итераторы и генераторы

В последней секции предыдущей главы мы обсудили важность последовательностей и способа их реализации в функциональном программировании. Специальные объекты — итераторы представляют последовательность в виде одного объекта который вычисляет и возвращает следующий элемент последовательности когда это необходимо. 

### 8.1 Итераторы

Итерируемый объект Python это любой объект который имеет специальный метод `__iter__` возвращающий итератор. Вызов метода производится функцией `iter(obj)`. Итерируемые объекты используются в цикле `for…in`, примерами таких типов являются списки, кортежи, словари и множества. Итераторы — это объекты реализующие протокол итераторов. Протокол итераторов определяет два обязательных для итератора метода: `__iter__` и `__next__`.

Метод `__iter__` вызывается при инициализации итератора. Он должен возвращать объект содержащий метод `__next__`.

Метод `__next__` вызывается стандартной функцией `next()` принимающей на вход итератор. Метод итератора `__next__` должен возвращать следующее значение итерируемого объекта. Если последовательность закончилась метод должен сгенерировать исключение `StopIteration`, как сигнал к окончанию окончания процесса перебора. Метод `__next__` и исключение `StopIteration` используется циклом `for..in` для перебора последовательностей.

Различайте итерируемый объект и итератор, потому что итерируемый объект это не всегда итератор:

```python
x = [1, 2, 3]
print(type(x)) # <class 'list'>

x_iter = iter(x)
print(type(x_iter)) # <class 'list_iterator'>

# x это итерируемый объект и может использоваться в циеле for..in
# но x это не итератор, так как не содержит метод __next__
print(dir(x))
# ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

# x_iter is это итератор так как содержит метод __iter__ и __next__
print(dir(x_iter))
# ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__length_hint__', '__lt__', '__ne__', '__new__', '__next__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__']
```

Итерируемый объект может сам быть итератором, и при вызове метода `__iter__` возвращать сам себя. Мы рассмотрим это далее.

Любой класс полностью реализующий протокол итераторов может использоваться как итератор. Проиллюстрируем это реализацией итератора возвращающего числа Фибоначчи до заданного максимального значения:

```python
class Fib:
    def __init__(self, max):
        self.max = max

    def __iter__(self):
        self.a = 0
        self.b = 1
        return self 
        # объект является одновременно и итератором и итерируемым объектом

    def __next__(self):
        fib = self.a
        if fib > self.max:
            raise StopIteration
        self.a, self.b = self.b, self.a + self.b
        return fib


for i in Fib(10):
  print(i)
# 0
# 1
# 1
# 2
# 3
# 5
# 8
```

Пользовательская функция `range` для перебора числе может быть реализована в виде итератора:

```python
class CustomRange:
    def __init__(self, max):
        self.max = max
        
    def __iter__(self):
        self.curr = 0
        return self
    
    def __next__(self):
        numb = self.curr
        if self.curr >= self.max:
            raise StopIteration
        self.curr += 1
        return numb


for i in CustomRange(10):
    print(i)
# 0
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
```

Рассмотрим два последних примера подробнее. Суть итератора в том что объект-итератор знает как вычислить элементы последовательности и возвращает их только когда они нужны, не все сразу. Объект `CustomRange` не возвращает все элементы в диапазоне при инициализации, вместо этого он имеет метод `__iter__` через который возвращает объект итератора. А объект итератора возвращает следующий элемент используя шаги заданные в методе `__next__`. Возможно даже объявить функцию `range` возвращающую все положительные целые числа (бесконечная последовательность) просто удалив верхнюю границу в методе `__next__`.

Та же идея применяется к итератору `Fib` и встроенным функциям возвращающим последовательности. Например, встроенная функция `range` не возвращает список, как может показаться, а возвращает объект который возвращает итератор при вызове метода `__iter__`. Рассмотрим это на примере:

```python
ran = range(0, 10)
print(type(ran)) # <class 'range'>


print(dir(ran))
# ['__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index', 'start', 'step', 'stop']

iter = ran.__iter__()
print(iter) # <range_iterator object at 0x1012a4090>

print(type(iter)) # <class 'range_iterator'>

print(iter.__next__()) # 0
print(iter.__next__()) # 1
print(iter.__next__()) # 2
print(iter.__next__()) # 3
print(iter.__next__()) # 4
print(iter.__next__()) # 5
print(iter.__next__()) # 6
print(iter.__next__()) # 7
print(iter.__next__()) # 8
print(iter.__next__()) # 9

print(iter.__next__())
# Traceback (most recent call last):
# File "<stdin>", line 1, in <module>
# StopIteration
```

```python
ran = range(10)
print(ran) # range(0, 10)

print(list(ran)) # используем список для получения всей последовательности
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Протокол итератора реализует форму вычислений называемую ленивыми вычислениями: в каждый момент времени производится только необходимая в этот момент работа.

#### Модуль itertools

Концепция итераторов насколько важна что Python содержит модуль `itertools` предоставляющий несколько функций общего назначения возвращающих итераторы. Если передать результаты этих функций в конструктор списков `list()`, то полная последовательность будет получена сразу.

`accumulate(iterable[, func])`

Функция имеет два параметра: обязательный итерируемый объект и необязательную функцию со значением по умолчанию функцией `operator.add`.  Передаваемая функция должна принимать два аргумента и возвращать единичное значение. Элементы итерируемого объекта должны подходить для передачи в эту функцию. Вызов `accumulate` возвращает итератор представляющий результат применения переданной функции к элементам итерируемого объекта. Первый элемент, возвращаемый итератором, это первый элемент из итерируемого объекта, а последующие элементы это результат применения функции `func(n-элемент, предыдущий результат итератора)`.

```python
from itertools import *

print(accumulate([1, 2, 3, 4, 5]))
# <itertools.accumulate object at 0x101c67c08>

print(list(accumulate([1, 2, 3, 4, 5])))
# [1, 3, 6, 10, 15]


import operator

print(accumulate(range(1, 10), operator.mul))
# <itertools.accumulate object at 0x101c6d0c8>

print(list(accumulate(range(1, 10), operator.mul)))
# [1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
```

`chain(*iterables)`

Функция принимает итерируемые объекты которые содержат другие итерируемые объекты и возвращает итератор представляющий объединение всех итерируемых объектов которые внутри переданных итерируемых объектов.

```python
from itertools import chain

x = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]

print(chain.from_iterable(x)) # <itertools.chain object at 0x101c6a208>

print(list(chain.from_iterable(x)))
# ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
```

`combinations(iterable, r)`

Функция возвращает итератор представляющий множество из `r` элементов подпоследовательностей элементов из переданного итерируемого объекта `iterable`. Элементы рассматриваются как уникальные на основе их значения, не на основе их позиции.

```python
from itertools import  combinations

print(combinations('ABCDE', 3))
# <itertools.combinations object at 0x101c71138>

print(list(combinations('ABCDE', 3)))
# [('A', 'B', 'C'), ('A', 'B', 'D'), ('A', 'B', 'E'), ('A', 'C', 'D'), ('A', 'C', 'E'), ('A', 'D', 'E'), ('B', 'C', 'D'), ('B', 'C', 'E'), ('B', 'D', 'E'), ('C', 'D', 'E')]
```

`filterfalse(predicate, iterable)`

Функция возвращает итератор который фильтрует элементы из итерируемого объекта `iterable`. Этот итератор возвращает только те объекты для которых функция `predicate` возвращает `False`. Если `predicate` равна `None` то итератор возвращает все элементы равные `False`.

`groupby(iterable, key=None)`

Функция возвращает итератор который возвращает последовательные ключи и соответствующие им группы из итерируемого объекта.

Если передаётся функция `key` то она используется для преобразования элементов из `iterable` в ключи. Если `key` не задан или равен `None` то элементы из `iterable` используются без изменения.  

Обычно, итерируемый объект уже должен быть отсортирован с помощью используемой функции `key`. 

```python
from itertools import groupby


a = {k: list(g) for k, g in groupby('AAAABBBCCD')}
print(a)
# {'D': ['D'], 'B': ['B', 'B', 'B'], 'A': ['A', 'A', 'A', 'A'], 'C': ['C', 'C']}


b = [k for k, g in groupby('AAAABBBCCDAABBB')]
print(b)
# ['A', 'B', 'C', 'D', 'A', 'B']
```

`islice(terable, start, stop[, step])`

Возвращает итератор которые возвращает элементы из итерируемого объекта внутри заданного диапазона. Если `start` не равен нулю то элементы из начала последовательности пропускаются пока не будет достигнут номер `start`. Затем элементы возвращаются последовательно с пропуском `step` элементов, если `step` больше единицы, пока не закончатся элементы.

В отличии от обычных срезов (slicing) функция не поддерживает негативную значения для `start`, `stop` и `step`.

`permutation(iterable, r=None)`

Функция возвращает перестановку длины `r` из элементов `iterable`. Если `r` не задан или равен `None`, то вместо `r` используется длина `iterable`. Элементы рассматриваются как уникальные на основе их позиции, не на основе значения, это отличие от сочетаний (`combinations`) рассмотренных выше. Так что если элементы уникальные, то каждая перестановка тоже будет уникальная.

`product(*iterables, repeat=1)`

Возвращает итератор который возвращает элементы картезианского произведения выходящих итерируемых объектов. Эта функция эквивалентна вложенным циклам `for` в генераторах списков. Например, `product(A, B)` вернёт итератор который вернёт значения аналогичные `[(x, y) for x in A for y in B]`. Функция может вычислить произведение итерируемого объекта на самого себя с помощью аргумента `repeat`. Например, `product(A, repeat=4)` означает то же что и `product(A, A, A, A)`.

### 8.2 Генераторы

