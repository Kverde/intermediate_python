% Intermediate Python
% Obi Ike-Nwosu
% leanpub.com, 2016

# Intermediate Python

Перевод книги [Intermediate Python](https://leanpub.com/intermediatepython) Obi Ike-Nwosu. Перевод выполнен с сокращениями, часть текста и примеры изменены.

## 1. Благодарности

Текст с благодарностями автора оригинального издания без корректировок.

I would love to take the opportunity to thank all who have reviewed and spotted issues in the manuscript. This includes but is not limited to Ngozi Nwosu for taking the time out to review the whole manual and point out a whole load of grammatical errors, Olivia Enewally, Roman Turna and Abhen Ng for pointing out some factual and grammatical errors.A whole lot of other people on Reddit have pointed out errors and to those people I am really grateful. 

Without the input of all these people, this manuscript would be worth less than it currently is. Thank you all!

## 2. Введение

Эта книга рассчитана на средний уровень знакомства с Python. В качестве интерпретатора подразумевается [CPython](https://www.python.org/). [Документация](https://docs.python.org/3/reference/index.html) последней стабильной версии.

## 3. Очень короткий учебник

Этот короткий учебник раскрывает основные концепции и возможности языка программирования Python.

### 3.1 Использование Python

Python установлен по умолчанию на Unix-системах. Для проверки установлен ли Python, откройте командную строку и введите `python`. Если Python не установлен то откройте [сайт Python](https://www.python.org/) и следуйте инструкциям для вашей платформы.

Если после установки Python не запускается из командной строки, проверьте добавлен ли путь к интерпретатору в системные пути.

Запуск интерпретатора командой `python` начинает интерактивную сессию [REPL](https://ru.wikipedia.org/wiki/REPL). Основная подсказка `>>>` предлагает ввести команду, вторичная подсказка `...` сигнализирует о продолжении предыдущей инструкции:

```python
>>> def hello():
...     print("Hello world")
...
>>>
```

Пользователь вводит инструкции python и немедленно получает ответ. В режиме REPL Python может использоваться как продвинутый калькулятор:

```python
Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:21:23) [MSC v.1916 32 bit (In
tel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> a = 3
>>> b = 3
>>> a * b + 5
14
>>>
```

Введите Ctrl+Z для завершения сессии интерпритатора.

### 3.2 Операторы Python, строки и отступы

Программа на Python состоит из логических строк ограниченных токеном **NEWLINE**. Каждая логическая строка эквивалентна простому оператору. Составные операторы формируются из нескольких логических строк.

Логическая строка создаётся из одной или нескольких физических строк используя явные или не явные правила объединения строк. Физическая строка — это последовательность символов завершающаяся символами перевода строки (end-of-line sequence). Python неявно рассматривает физические строки как логические, устраняя необходимость в точке с запятой для разделения выражений. Однако точка с запятой может использоваться для разделения одной физической строки на несколько логических:

```Python
>>> i = 5; print i;
5
```

Несколько физических строк в явном виде объединяются в одну логическую символом "\\":

```Python
>>> name = "Obi Ike-Nwosu"
>>> cleaned_name = name.replace("-", " "). \
... replace(" ", "")
>>> cleaned_name
'ObiIkeNwosu'
>>>
```

Физические строки соединяются неявно, без использования символа продолжения строки ("\\"), когда выражение находится в тройных строковых кавычках, заключено в скобки `(...)`, `[...]`, или `{...}`.

Python содержит два типа операторов.

Простые операторы занимающие одиночные логические строки. Они включают в себя присваивание, **yield** и др. Общий синтаксис простых операторов:

```
simple_stmt ::= expression_stmt
            | assert_stmt
            | assignment_stmt
            | augmented_assignment_stmt
            | pass_stmt
            | del_stmt
            | return_stmt
            | yield_stmt
            | raise_stmt
            | break_stmt
            | continue_stmt
            | import_stmt
            | global_stmt
            | nonlocal_stmt
```

Составные операторы занимающие несколько логических строк. Они включают в себя выражения циклов **while** и **for**. Общий синтаксис составных операторов:

```
compound_stmt ::= if_stmt
              | while_stmt
              | for_stmt
              | try_stmt
              | with_stmt
              | funcdef
              | classdef

suite ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT

statement ::= stmt_list NEWLINE | compound_stmt

stmt_list ::= simple_stmt (";" simple_stmt)* [";"]
```

Составные операторы содержат одно или несколько предложений (clause). Предложение состоит из заголовка (header) и тела (suite). Заголовки предложений для одного составного оператора имеют одинаковый отступ и начинаются с уникального идентификатора (**while**, **if** и т.д.) и с двоеточия. Составной оператор **if** определяется так:

```
if_stmt ::=  "if" expression ":" suite
             ( "elif" expression ":" suite )*
             ["else" ":" suite]
```

Выполнение тела предложения контролируется заголовком:

```Python
>>> num = 6
# оператор if является составным оператором
    # Заголовок предложения контролирует выполнение следующего блока с отступом
>>> if num % 2 == 0:
        # блок тела с отступом
...     print("The number {} is even".format(num))
...
The number 6 is even
>>>
```

Тело (suite) может быть набором из одного или нескольких операторов который следуют за двоеточием заголовка, в этом случае, операторы разделяются точкой с запятой:

```Python
>>> x = 1
>>> y = 2
>>> z = 3
>>> if x < y < z: print(x); print(y); print(z)
...
1
2
3
```

Но обычно тело (suite) записывается со следующей после заголовка строки в виде одного или нескольких операторов с отступом:

```Python
>>> x = 1
>>> y = 2
>>> z = 3
>>> if x < y < z:
...    print(x)
...    print(y);
...    print(z)
...
1
2
3
```

Отступы используются для обозначения блоков кода таких как тела функций, условий, циклов и классов. Ведущий пробел в начале логической строки используется для вычисления отступа для этой строки, который, в свою очередь, используется для определения группировки оператора. Отступ используемый в теле блока всегда должен совпадать с отступом первого оператора в блоке.

### 3. Строки

Строки в Python обрамляются двойными "..." или одинарными '...' кавычками. Спецсимволы указываются внутри строки с экранированием:

```python
# кавычка используется как апостроф, поэтому мы экранируем её чтобы 
# предотвратить завершение строки
>>> name = 'men\'s'
>>> name
"men's"
>>>
```

Для того чтобы отключить обработку спецсимволов в строке, добавьте перед строкой символ **r**:

```python
>>> print('C:\some\name') # здесь \n означает перевод строки!
C:\some
ame
>>> print(r'C:\some\name') # добавлен r перед кавычкой
C:\some\name
```

Многострочные строковые литералы задаются тройными кавычками. Перевод строки автоматически добавляется при достижении конца строки:

```python
>>> para = """hello world I am putting together a
... book for beginners to get to the next level in python"""
# Обратите внимание на символ перевод строки
>>> para
'hello world I am putting together a \nbook for beginners to get to the next level in python'
# При выводе текст разделяется на несколько срок
>>> print(para)
hello world I am putting together a
book for beginners to get to the next level in python
>>>

Чтобы перевод строки не добавлялся используйте символ **\** в конце строки:

​```python
>>> para = """hello world I am putting together a \
... book for beginners to get to the next level in python"""
>>> para
'hello world I am putting together a book for beginners to get to the next level in python'
>>> print(para)
hello world I am putting together a book for beginners to get to the next level in python
>>>
```

Строки неизменяемые, один раз созданная строка не может быть изменена. Для символов отдельного типа нет, они являются строками длинной в 1 символ. Строки являются одним из типов последовательностей, поэтому поддерживают все операции с последовательностями, за исключением присваивания по индексу из-за неизменяемости. Обращение к отдельному символу происходит по индексу:

```python
>>> name = 'obiesie'
>>> name[1]
'b'
>>>
```

Строки соединяются оператором **+**:

```python
>>> name = 'obiesie'
>>> surname = " Ike-Nwosu"
>>> full_name = name + surname
>>> full_name
'obiesie Ike-Nwosu'
>>>
```

Написанные рядом строковые литералы соединяются автоматически:

```python
>>> 'Py' 'thon'
'Python'
>>>
```

Встроенная функция **len** возвращает длину строки:

```python
>>> name = "obi"
>>> len(name)
3
>>>
```

### 3.4 Управляющие конструкции

#### if-else и if-elif-else

Оператор **if** применяется для условного выполнения блока кода:

```python
>>> name = "obi"
>>> if name == "obi":
...     print("Hello Obi")
...
Hello Obi
>>>
```

За оператором **if** следует ноль или больше операторов **elif** и не обязательный оператор **else**. Если не один из операторов **if** или **elif** не был выполнен, то выполняется блок **else**:

```python
>>> if name == "obi":
...     print("Hello Obi")
... elif name == "chuks":
...     print("Hello chuks")
... else:
...     print("Hello Stranger")
Hello Stranger
>>>
```

#### for и range

В Python два вида циклов: **while** и **for**.

Оператор **for** используется для перебора последовательностей (list, set, tuple и т.д.). В общем случае, цикл **for** используется для перебора любых объектов реализующих протокол итератора Python (python iterator protocol). Подробнее это будет описано в следующих главах.

Пример использования цикла **for**:

```python
>>> names = ["Joe", "Obi", "Chris", "Nkem"]
>>> for name in names:
...     print(name)
...
Joe
Obi
Chris
Nkem
>>>
```

Большинство языков программирования использует синтаксис похожий на этот для перебора последовательности чисел:

```
for(int x = 10; x < 20; x = x+1) {
// do something here
}
```

В Python используется конструкция **range()** для генерации арифметической прогрессии целых чисел:

```python
>>> for i in range(10, 20):
...     print i
...
10
11
12
13
14
15
16
17
18
19
```

Функция range(start, stop, step) допускает три аргумента. Значение параметра **stop** не входит в возвращаемую последовательность.

#### while

Оператор **while** выполняет блок кода пока условное выражение вычисляется в **True**:

```python
>>> counter = 10
>>> while counter > 0: # условное выражение 'counter > 0'
...     print(counter)
...     counter = counter - 1
...
10
9
8
7
6
5
4
3
2
1
```

#### break и continue

Команда **break** завершает выполнение цикла, после **break** происходит немедленный выход из цикла.

```python
>>> for i in range(10):
...     if i == 5:
...         break
...     else:
...         print(i)
...
0
1
2
3
4
```

Команда **continue** принудительно запускает следующую итерацию цикла. Все команды внутри цикла после **continue** игнорируются.

```python
>>> for i in range(10):
        # если i равно 5 то начинаем новую итерацию цикла, без выполнения остальных команд
...     if i == 5:
...         continue
...     print("The value is " + str(i))
...
The value is 0
The value is 1
The value is 2
The value is 3
The value is 4
# no printed value for i == 5
The value is 6
The value is 7
The value is 8
The value is 9
```

В примере выше, значение 5 не напечатано, из-за условия и команды **continue**. Все остальные значения напечатаны.

#### циклы и else 

В Python ключевое слово **else** применяется вместе с операторами цикла. Блок после **else** выполняется если цикл не был завершён оператором **break**.

```python
# loop exits normally
>>> for i in range(10):
...     print(i)
... else:
...     print("I am in quirky else loop")
...
0
1
2
3
4
5
6
7
8
9
I am in quirky else loop
```

Если цикл завершён оператором **break**, то блок **else** пропускается:

```python
>>> for i in range(10):
...     if i == 5:
...        break
...     print(i)
... else:
...     print("I am in quirky else loop")
...
0
1
2
3
4
```

#### Enumerate

Иногда нужно перебрать коллекцию, поучая одновременно индекс и значение элементов. Можно использовать такой подход:

```python
>>> names = ["Joe", "Obi", "Chris", "Jamie"]
>>> name_count = len(names)
>>> index = 0
>>> while index < name_count:
...   print("{}. {}".format(index, names[index]))
...   index = index + 1
...
0. Joe
1. Obi
2. Chris
3. Jamie
```

В Python есть более эффективное решение с функцией **enumerate**:

```python
>>> for index, name in enumerate(names):
...     print("{}. {}".format(index, name))
...
0. Joe
1. Obi
2. Chris
3. Jamie
>>>
```
### 3.5 Функции

Именованные функции определяются ключевым словом **def**, за которым следует название функции и список параметров в скобках. Ключевое слово **return** используется для возвращения значения функции:

```python
def full_name(first_name, last_name):
    return " ".join((first_name, last_name))
```

Для вызова функции используется её имя, параметры передаются в скобках:

```python
full_name("Obi", "Ike-Nwosu")
```

Функции могут вернуть несколько значений в виде кортежа. В следующим примере функция возвращает частное и остаток от деления:

```python
>>> def divide(a, b):
...     return divmod(q, r)
...
>>> divide(7, 2)
(3, 1)
>>>
```

Функция без **return** всегда возвращает **None**:

```python
>>> def print_name(first_name, last_name):
...     print(" ".join((first_name, last_name)))
...
>>> print_name("Obi", "Ike-Nwosu")
Obi Ike-Nwosu
>>> x = print_name("Obi", "Ike-Nwosu")
Obi Ike-Nwosu
>>> x
>>> type(x)
<type 'NoneType'>
>>>
```

Ключевое слово **return** может использоваться без значения чтобы прервать выполнение функции:

```python
>>> def dont_return_value():
...     print("How to use return keyword without a value")
...     return
...
>>> dont_return_value()
```

Выражение **lambda** позволяет объявить функцию без имени. Такая функция состоит всего из одного выражения которое и является значением функции. Поэтому не требуется использовать **return**.


```python
>>> square_of_number = lambda x: x**2
>>> square_of_number
<function <lambda> at 0x101a07158>
>>> square_of_number(2)
4
>>>
```

Функция созданная через **lambda** эквивалентна именованной функции определённой через **def**.

### 3.6 Структуры данных

Python содержит встроенные типы данных: списки, кортежи, словари.

#### Списки

Списки создаются используя квадратные скобки или функцию `list()`:

```python
my_list1 = [] # Пустой список
my_list2 = list() # Пустой список
```

Список сохраняет порядок элементов с которым создаётся или в котором элементы добавляются. Списки являются последовательностями и поддерживают доступ по индексу, другие свойства последовательностей будут описаны в следующих главах. 

Первый элемент списка находится под индексом 0, последний — на единицу меньше длины списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name[0]
'obi'
>>> name[1]
'ike'
>>> name[2]
'nwosu'
```

Метод `append()` добавляет элемент в список.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name.append("nkem")
>>> names
["obi", "ike", "nwosu", "nkem"]
```

Метод `insert()` добавляет элемент в любое место списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name.insert(1, "nkem")
>>> names
["obi", "nkem", "ike", "nwosu"]
```

Оператор `+` позволяет объединить два и более списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name1 = ["James"]
>>> name + name1
["obi", "ike", "nwosu", "James"]
```

Для просмотра всех методов списка запустите команду `help(list)`.

#### Кортежи

Кортеж тоже является последовательностью и создается элементами разделёнными запятыми:

```python
>>> companies = "Google", "Microsoft", "Tesla"
>>> companies
('Google', 'Microsoft', 'Tesla')
```

При определении непустого кортежа скобки не обязательны, но они становятся обязательными когда кортеж является частью большего выражения. Пустой кортеж создаётся пустой парой скобок:

```python
>>> companies = ()
>>> type(companies)
<class 'tuple'>
```
При определении кортежа с одним элементом запятая за ним обязательна.

```python
>>> company = "Google",
>>> type(company)
<class 'tuple'>

>>> company = ("Google",)
>>> type(company)
<class 'tuple'>
```

Пропуск запятой означает что задано обычное значение, не кортеж.

```python
>>> company = ("Google")
>>> company
'Google'

>>> type(company)
<class 'str'>
```

Кортежи индексируются как списки, но неизменямы.

```python
>>> companies = ("Google", "Microsoft", "Palantir")
>>> companies[0]
'Google'
>>> companies[0] = "Boeing"
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

В тоже время, если элементом кортежа является изменяемые объект, такой как список, то он может быть изменен.

```python
>>> companies = (["lockheedMartin", "Boeing"], ["Google", "Microsoft"])
>>> companies
(['lockheedMartin', 'Boeing'], ['Google', 'Microsoft'])
>>> companies[0].append("SpaceX")
>>> companies
(['lockheedMartin', 'Boeing', 'SpaceX'], ['Google', 'Microsoft'])
```

#### Множества

Множества это неупорядоченные коллекции объектов не содержащие дубликатов. Пустое множество создаётся функцией `set()` или круглыми скобками `{}`.  Множества неупорядоченны поэтому к элементам множества нельзя обратится по индексу. Множества, за исключением frozen set, изменяемы.

```python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> basket_set = set()
>>> basket_set
set()
>>> basket_set.update(basket)
>>> basket_set
{'pear', 'orange', 'apple', 'banana'}
>>> basket_set.add("clementine")
>>> basket_set
{'pear', 'orange', 'apple', 'banana', 'clementine'}
>>> basket_set.remove("apple")
>>> basket_set
{'pear', 'orange', 'banana', 'clementine'}
```

#### Словари

Словарь в Python похож на ассоциативный массив или хеш-таблицу в других языках. Словари индексируются по неизменяемому ключу. Для создания словаря используются фигурные скобки `{}` или функция`dict()`. Словарь — неупорядоченное множество пар ключ-значение в которых ключ уникален. Пример инициализации словаря:

```python
ages = {"obi": 24,
"nkem": 23,
"Chris": 23
}
```

Основные операции словаря это сохранение значения по ключу и доступ к значению по ключу. Доступ к значению осуществляется через квадратные скобки:

```python
>>> ages["obi"]
24
```

Словари изменяемы, значения связанные с ключами могут менятся, добавлятся и удалятся.

Структуры данных Python не ограничиваются приведёнными в этом разделе. Например, модуль `collections` содержит очереди, деки и другие коллекции. В то же время структуры приведённые в этом разделе используются в большинстве приложений на Python.

Используйте функцию help с параметром в виде названия типа данных для детального изучения типа.

```python
help(list)
help(tuple)
help(set)
help(dict)
```

### 3.7 Классы

Выражение `class` используется для определения новых типов в Python:

```python
class Account:
    # классовая переменная общая для всех экземпляров классов
    num_accounts = 0

    def __init__(self, name, balance):
    # переменные экзепляра
    self.name = name
    self.balance = balance
    
    # изменение классовой переменной 
    Account.num_accounts += 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)

    @classmethod
    def from_dict(cls, params):
        params_dict = json.loads(params)
        return cls(params_dict.get("name"), params_dict.get("balance"))
```

Классы в Python, как в других языках, могут содержать классовые пеменные, переменные объекта, классовые методы, статичные методы и методы объекта. 

При определении класса, имя родителського класса указывается в скобках после названия класса.

```python
class dog(animal):

```

Метод `__init__` похож на конструктор в других языках программирования. В этом методе инициализируются переменные объекта. Для создания объекта класса `Account` нужно передать аргументы указанные в `__init__` за исключением `self`:

```python
>>> acct = Account("obie", 10000000)
```

Методы обявленные с аргументом `self` являются методами объекта. Аргумент `self` является ссылкой на объект. Методы вызываются через точку:

```python
>>> acct = Account("obie", 10000000)
>>> account.inquiry()
Name=obie, balance=10000000
```

Встроенная функция `dir` предназачена для исследования объектов и печатает все методы, переменные и атрибуты объекта который в неё передан.

### 3.8 Модули

С ростом размера и сложности кода он всё больше нуждается в структуризации. Python позволяет разделить кода на несколько файлов. Каждый файл назвывается модулем имеет расширений `.py`. Для обращения к определениям из файла его необходимо имортировать командой `import`. 

```python
>>> import Account
>>> acct = Account.Account("obie", 10000000)
```

Команда `import` требует имя модуля без расширения `.py`.  При иморте создается пространство имён с именем модуля (в примере `Account`). Доступ к определням из пространства имён осуществляется через точку (`.`).

Ключевое слово `as` задаёт название пространство имён отличное от названия модуля:

```python
>>> import Account as acct
>>> account = acct.Account("obie". 10000000)
```

Возможнен иморт отдельных определений из модуля вместо всего модуля:

```python
>>> from Account import Account
>>> account = Account("obie", 10000000)
```

Возможно импортрровать все опредления из модуля:

>>> from Account import *

Такой способ не рекуомендуется, так как приводит к конфликтам разных пространств имён: импортированные имена из одного модуля перезаписываются импортом из другого.

Модули это обычные объекты Python, их можно исследовать функцией `dir`. Модули могут быть сгруппированы в пакеты. Пакеты и модули детальнее описаны в следующих главах.

### 3.9 Исключения

Python поддерживает исключения и перехват исключений. Например, при делении на ноль интерпритатор выбросит исключение `ZeroDivisionError`.

```python
>>> 2/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>>
```
Во время выполнения программы, исключение генерируется когда происходит ошибка. Если исключение не обработано, то на экран будет выведен стек вызовов. В обычном случае необработанное исключение остановит выполнение программы.

Исключения перехватываются командой `try...catch`:

```python
>>> try:
...     2/0
... except ZeroDivisionError as e:
...     print("Attempting to divide by 0. Not allowed")
...
Attempting to divide by 0. Not allowed
>>>
```
Исключения бывают разных типов. В примере выше обрабатывается исключение `ZeroDivisionError` и если в защищенном коде возникнет другое исключение, то работа программы остановится.

Для перехвата любого исключения тип исключения не указывается

```python
>>> try:
...     2/0
... except:
...     print("Attempting to divide by 0. Not allowed")
...
Attempting to divide by 0. Not allowed
>>>
```
Такая конструкция не рекомендуется, так как невозможно сказать какой тип возникшего исключения.

Для объявления пользовательского типа исключения создаётся класс наследуемый от `Excption`. Пользовательские исключения перехватываются тем же способом что и стандартные.

### 3.10 Ввод и вывод

Python поддерживает операции ввода и вывода из разных источников. Пример чтения файла:

```python
f = open("afile.txt")
line = f.readline()
while line:
    print(line)
    line = f.readline()
```

Метод `open` возвращает объект типа `file` или генерирует исключение если файл не сущетвует. Объект типа `file` поддерживает методы такие как чтение всего файла в строку (`read`) или чтение одной строки файла (`readline`). Python поддерживает синтаксический сахар для перебора всех строк файла:

```python
for line in open("afile.txt"):
    print(line)
```

Пример записи в файл:

```python
f = open("out.txt", "w")
contents = ["I", "love", "python"]
for content in contents:
    f.write(content)
f.close()
```

Python так же поддерживает запись в стандартный поток вывода и чтение из стандартного потока ввода.

```python
name = input('What is your name? ')
print(f'Hello, {name}')
```

### 3.11 Документация

Интерпретатор Python содержит много встроенной документации. Для получения документации используйте команду `help`, в параметре передаётся название класса или онструкции языка.

```python
help('try')
help(list)
```

## 4.  Intermezzo: Глоссарий

В этой книге используются термины и эзотерический функции Python понимание которые является условием глубокого понимания Python. Ниже даётся объяснение этих терминов и функций.

### 4.1 Имена и связывание

В Python, на объекты ссылаются через имена. Имена аналогичны переменным в C++ или Java.

```
>>> x = 5
```

В примере выше, `x` &mdash; имя которое ссылается на объект `5`. Процесс присваивания ссылки на `5` в `x` называется связыванием. Связывание приводит к тому что имя ассоциируется с объектом. 

Связывание происходит в разных ситуациях: при присваивании и при вызове методов, когда параметры связываются с аргументами.

Важная особенность: **имена являются только ссылками без связанного с ними типа; имена ссылаются на объекты которые имеют тип**.

Присваивание создаёт новое имя в самой внутренней области видимости программы: если присваивание выполняется в коде модуля &mdash; имя добавляется в глобальные переменные модуля, если в коде функции &mdash; в локальные переменные функции.

### 4.2 Блоки кода

Блок кода это часть программы запускаемая как одно целое. Модули, функции и класс являются примерами блоков кода. Команды вводимые в REPL скрипты запущенные с опцией `-c` тоже блоки кода. Блок кода содержит пространства имён связанные с ним. Например, блок кода модуль имеет доступ к глобальному пространству имён, а блок кода функция имеет доступ к локальному и глобальному пространству имён.

### 4.3 Пространства имён

Пространство имён — контекст в котором данное множество имён связано с объектами. Сейчас пространства имён реализованы в виде словаря. Например, пространство имён встроенных функций реализуется словарём `__builtins__.__dict__`.

Интерпретатору доступны несколько пространств имён, включая глобальное пространство имён, пространство имён встроенных функций и локальное пространство имён. Эти пространства имён создаются в разное время и имеют разное время жизни. 

Например, локальное пространство имён создаётся при вызове функции и уничтожается при выходе из функции. Глобальное пространство имён создаётся в начале запуска модуля и все имена определённые в нём доступны для всего модуля. Пространство имён встроенных функций создаётся при запуске интерпретатора и содержит все встроенные имена. Эти три основные пространства имён доступные интерпретатору.


### 4.4 Области видимости

Область видимости это часть программы в которой множество имён (пространств имён) видимы и доступны напрямую. Прямой доступ важная характеристика области видимости и будет объяснена при разговоре о классах. В простом смысле, это означает что имя может использовать как есть, без использования точки для доступа к имени, как например `SomeClassOrModule.name`. Во время выполнения следующие области видимости могут быть доступны

1. Самая внутренняя область видимости с локальными именами.
2. Область видимости внешней функции если она есть (для вложенных функций)
3. Глобальная область видимости текущего модуля
4. Пространство имён встроенных функций

При использовании имени интерпретатор ищет в пространствах имён областей видимости в порядке указном выше и если имя не найдено генерирует исключение.

Python поддерживает статическое пространство имён (static scoping,  lexical scoping). Это означает что для определения того какая переменная используется в данном блоке достаточно просмотра текста программы. TODO Link

#### Примечание

Python содержит правила предотвращающие изменение имени в глобальной области видимости из локальной области области видимости. Попытка сделать это приведёт к исключению `UnboundLocalError`.

```python
>>> a = 1
>>> def inc_a(): a += 2
...
>>> inc_a()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 1, in inc_a
UnboundLocalError: local variable 'a' referenced before assignment
```

Для изменения объекта из глобальной области видимости в локальной области видимости применяется ключевое слово `global`. Оно должно использоваться до того как происходит изменение объекта.

```python
>>> a = 1
>>> def inc_a():
...     global a
...     a += 1
...
>>> inc_a()
>>> a
2
```

Ключевое слово `nonlocal` используется при необходимости изменения привязки переменной во внешней не глобальной области видимости из внутренней области видимости. Это полезно во вложенных функциях (замыканиях). Пример использования `nonlocal` при определении объектов-счётчиков: 

```python
>>> def make_counter():
...     count = 0
...     def counter():
...         nonlocal count # nonlocal captures the count binding from enclosing scope not global scope
...         count += 1
...         return count
...     return counter
...
>>> counter_1 = make_counter()
>>> counter_2 = make_counter()
>>> counter_1()
1
>>> counter_1()
2
>>> counter_2()
1
>>> counter_2()
2
```

### 4.5 eval()

Встроенная функция `eval` запускает выражение Python переданное в виде строки или объекта типа `code`. Сигнатура функции:

```python
eval(expression, globals=None, locals=None)
```

При вызове `eval` возвращает результат выражения:

```python
>>> eval("2 + 1") # note the expression is in a string
3
```

Аргумент `globals` должен быть словарём, а `locals` может быть любым отображением. Если `globals` не задан то вместо него используется текущее глобальное пространство имён. Это означает что у кода будет доступ ко всем именам текущего модуля.

```python
def g():
    return 4

print(eval('2 + 2 + g()')) # 8
```

Вместо строки в `eval` можно передать объект типа `code` полученный функцией `compile`.  `eval` и `exec` используется для запуска произвольного Python кода, например, в онлайн интерпретаторах Python.

### 4.6 exec()

`exec` похож на `eval`, он запускает строку (или объект типа `code`) с набором команд Python. Сигнатура `exec`:

```python
exec(object[, globals[, locals]])
```

Пример использования `exec` используя строку и текущее пространство имён:

```python
Python 3.4.2 (v3.4.2:ab2c023a9432, Oct 5 2014, 20:42:22)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.

>>> cont = open('acct.py', 'r').read()

>>> cont
'class Account:\n """base class for representing user accounts"""\n num_accounts = 0\n\n de\
f __init__(self, name, balance):\n self.name = name \n self.balance = balance \n \
Account.num_accounts += 1\n\n def del_account(self):\n Account.num_accounts -= 1\n\n \
def __getattr__(self, name):\n """handle attribute reference for non-existent attribute"""\n \
return "Hey I dont see any attribute called {}".format(name)\n\n def deposit(self, amt):\n\
self.balance = self.balance + amt \n\n def withdraw(self, amt):\n self.balance = s\
elf.balance - amt \n\n def inquiry(self):\n return "Name={}, balance={}".format(self.name,\
self.balance) \n\n'

>>> exec(cont)
# запускаем содержимое файла используя пространство имён по умочанию
>>> Account # теперь мы можем ссылаться на класс Account
<class '__main__.Account'>
>>>
```

Если необязательные аргументы пропущены когда запускается в текущей области видимости. Если задан только `global` то они используется для глобальных и локальных переменных. 

Если словарь переданный в `global` не содержит  ключа `__builtins__` то под этим ключом будет добавлена ссылка на пространство имён встроенных функций. Вставив под ключом `__builtins__` свой словарь можно добиться запрета или ограничения стандартных функций.

## 5. Objects 201

Любое значение в Python является объектом. Любой объект имеет идентификатор, тип и значение. Идентификатор объекта не меняется после создания объекта. 

Функция `id(obj)` возвращает идентификатор объекта. В CPython идентификатор объекта это адрес объекта в памяти. В других реализациях Python идентификатор объекта может генерироваться по другому принципу, но он обязательно должен уникально идентифицировать объект в интерпретаторе.

```python
>>> n = 5
>>> id(5)
1573971952
```

Оператор `is` сравнивает идентификаторы двух объектов и возвращает логическое значение.

```python
>>> n1 = 6
>>> n2 = 7
>>> n1 is n2
False
```

Функция `type()` возвращает тип объекта, тип тоже сам является объектом. Тип объекта, при нормальной работе, неизменяем. Тип объекта определяет операции которые поддерживает объект и возможный набор значений. Python динамический язык программирования потому что типы не связаны с переменными, так что переменная `x` сначала может ссылаться на число, а через некоторое время на строку.

```python
x = 1
x = "Nkem"
```

В тоже время Python является строго типизированным языком, так как интерпретатор не меняет тип объекта автоматически. Это, например, означает что при сложении строки и числа будет сгенерировано исключение:

```python
>>> x = "Nkem"
>>> x + 1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
```

Такое поведение отлично от других языков, например, от JavaScript где интерпретатор неявно конвертирует число в строку и соединит их.

Объекты Python бывают двух типов: изменяемые и неизменяемые.

**Изменяемые объекты**

Значения изменяемых объектов могут меняться. Например, список относится к изменяемым объектам, в него можно добавлять или удалять элементы:

```python
>>> a = [1, 2]
>>> a.append(3)
>>> a
[1, 2, 3]
```

Значения в Python всегда передаются по ссылке, это, в частности, означает что при передачи ссылки на значение в метод (любой объект), внутри метода будет использоваться ссылка на то же значение. Демонстрация такого поведения:

```python
>>> x
[1, 2, 3]
>>> y = x
# теперь x и y ссылаются на один список
>>> x.extend([4, 5, 6])
# изменение в x отражаются в y
>>> y
[1, 2, 3, 4, 5, 6]
```
`x` и `y` ссылаются на один объект поэтому неважно через какую ссылку было произведено изменение объекта. Важно понимать что `x` не содержит список, а только ссылку на него и при присваивании `y = x` в `y` так же помещается только ссылка на тот же самый список.

**Неизменяемые объекты**

Неизменяемые объекты не могут изменить своё значение. Кортежи являются неизменяемыми объектами: 

```python
>>> x = (1, 2, 3, 4)
>>> x[0]
1
>>> x[0] = 10
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>>
```

Неизменяемые объекты могут содержать изменяемые объекты. В этом случае значения изменяемых объектов может быть изменено, но не ссылка на сам изменяемый объект. Таким случаем является список внутри кортежа:

```python
>>> t = [1, 2, 3, 4]
>>> x = t,
>>> x
([1, 2, 3, 4],)
>>> x[0]
[1, 2, 3, 4]
>>> x[0].append(10)
>>> x
([1, 2, 3, 4, 10],)
>>>
```

###  5.1 Слабые и сильные ссылки на объекты

Объекты Python получают ссылки когда они связываются с именами. Связывание может произойти после присваивания, вызова метода с параметрами или другими способами. Каждый раз когда объект получает ссылку увеличивается счётчик ссылок. Значение счётчика ссылок можно получить функцией `sys.getrefcout()`:

```python
import sys

l = []
m = l

print(sys.getrefcount(l)) # 3
```
В примере три ссылки: `l`, `m` и ссылка из параметра `getrefcount`.

В Python применяется два типа ссылок: слабые и сильные. Если это точно не указано, то при упоминании ссылок речь идет о сильных ссылках, как в приведенном выше примере три сильные ссылки.

Главная особенность сильных ссылок — когда они создаются то счётчик ссылок увеличивается на 1. Сборщик мусора не удалит объект на который есть сильная ссылка, так как он удаляет только объекты счетчик ссылок которых равен 0.

Слабые ссылки не увеличивают счётчик ссылок объекта. Модуль `weakref` предназначен для работы со слабыми ссылками:

```python
import sys
import weakref


class Foo:
    pass


a = Foo()
b = a
print(sys.getrefcount(a)) # 3

c = weakref.ref(a)
print(sys.getrefcount(a)) # 3

print(c()) # <__main__.Foo object at 0x01481F88>
print(type(c)) # <class 'weakref'>
```

Функция `weakref.ref` возвращает объект при вызове которого (как вызов функции `c()`) возвращается объект на который слабая ссылка. Другая функция `weakref.proxy` так же создаёт слабую ссылку и возвращает объект который может использоваться как оригинальный объект без необходимости вызова:

```python
import sys
import weakref


class Foo:
    pass

    def get(self):
        return 23


a = Foo()
b = weakref.proxy(a)
print(sys.getrefcount(a)) # 2

print(b) # <__main__.Foo object at 0x03911F88>
print(b.get()) # 23
```

Когда все сильные ссылки на объект удалены, слабые ссылки тоже ссылку на объект и объект готов для уничтожения сборщиком мусора.

```python
import weakref


class Foo:
    pass


a = Foo()
b = weakref.ref(a)

del a

print(b) # <weakref at 0x03799AF0; dead>
print(b()) # None
```

### 5.2 Иерархия типов

В этом разделе перечислены категории встроенных типов Python.

#### Тип None

The None type is a singleton object that has a single value and this value is accessed through the built-in name None. 

Тип **None** это синглтон который содержит только одно значение и это значение доступно под встроенным именем `None`. Этот тип используется для обозначеия отсутствия значения, например, когда функция не возвращает значения в явном виде:

```python
def print_name(name):
    print(name)


name = print_name("nkem")

print(name) # None
print(type(name)) # <class 'NoneType'>
```

При преобразованию к логическому типу `None` становится `False`:

```python
print(bool(None)) # False
```

#### Тип NotImplemented

Тип **NotImplemented** так же является синглтоном с одним значением. Значение этого объекта доступно под встроенным именем `NotImplemented`. Такой объект используется чтобы делегировать поиск реализации метода интерпретатору вместо генерации исключений `NotImplementedError`:


```python
class Foo:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        if isinstance(other, Foo):
            print('Сравнение экземпляра Foo с другим экземпляром Foo')
            return other.value == self.value

        elif isinstance(other, Bar):
            print('Сравнение экземпляра Foo с экземпляром Bar')
            return other.value == self.value

        print('Невозможно сравнить экземпляр Foo с другим классом')
        return NotImplemented


class Bar:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        if isinstance(other, Bar):
            print('Сравнение экземпляра Bar с другим экземпляром Bar')
            return other.value == self.value

        print('Невозможно сравнить экземпляр Bar с другим классом')
        return NotImplemented
```

Эффект возврата `NotImplemented` наблюдается при попытке сравнения. `a == b` приводят к вызову `a.__eq__(b)`. В примере, классы `Foo` и `Bar` содержат реализацию для сравнения себя с другими объектами:

```python
f = Foo(1)
b = Bar(1)

res = f == b # Сравнение экземпляра Foo с экземпляром Bar
print(res) # True

res = f == f # Сравнение экземпляра Foo с другим экземпляром Foo
print(res) # True

res = b == f # Сравнение экземпляра Bar с другим экземпляром Bar
print(res) # True
```

If b is compared with f then b.__eq__(f) is invoked and the NotImplemented object is returned
because the implementation of __eq__() in Bar only supports comparison with a Bar instances.

Если `b` сравнивается с `f` то вызывается `b.__eq__(f)` и возвращается объект `NotImplemented`, так как реализация в `Bar` поддерживает сравнение только с экземпляром `Bar`. Несмотря на это операция сравнения будет выполнена:

```python
res = b == f
# Сравнение экземпляра Bar с другим экземпляром Bar
# Сравнение экземпляра Foo с экземпляром Bar
print(res) # True
```

Вызов  метода `b.__eq__(f)` возвращает `NotImplemented` заставляю интерпретатор вызывать `__eq__()` у объекта класса `Foo` и так как в этом методе сравнение реализовано, возвращается корректный результат сравнения.

Объект `NotImplmented` преобразовывается к логическому типу как `True`.

```python
print(bool(NotImplemented)) # True
```

#### Тип Ellipsis

Это ещё один синглтон с одним объектом-значением. Значение этого объекта доступно через литерал `...` или встроенное имя `Ellipsis`. Логическое значение этого объекта True:

```python
print(bool(...)) # True
```
Объект `Ellipsis` используется для индексации матриц, подробнее о нем написано в [документации по numpy](https://docs.scipy.org/doc/numpy/user/basics.indexing.html).

#### Числовые типы

Объекты числовых типов неизменяемы, созданное однажды значение не может быть изменено. Числовые типы делятся на несколько категорий.

**Целые числа**

Класс `int` представляет множество  положительных и отрицательных целых чисел. Целые числа не ограничены размером:

```python
print(238**238)
#42200323427409150751742179532592018252808661114071266629718376939092568551075505740268077803623642715001998769421215763628719631633378375087756319383725641630331895773386010866243028159828607385899087848942302738709343403640250275314218243930567432731458807734886574283968918955323573297631562415292893276034393336066052132808455118105272470307339550216091253570417050545677371810192238471803263478546492058686483752405946094606978411379079233793804753705243644236607675749522119768311584522527886912942059070222789851175661909205254663263392466134105108288691503104
```

**Логическое значения**

Тип `bool` представляет значения `True` и `False`.  `bool` является подтипом `int`:

```python
print(type(True).__base__) # <class 'int'>
```

Значения `False` и `True` ведут себя как 0 и 1 соответственно. При конвертации в строку получаются значения "True" и "False":

```python
x = 1
y = True
print(x + y) # 2

a = 1
b = False
print(a + b) # 1

print(b == 0) # True
print(y == 1) # True

print(str(True)) # 'True'
print(str(False)) # 'False'
```

**Числа с плавающей запятой**

Тип `float` представляет числа с плавающей запятой. Точные ограничения этого типа зависят от реализации интерпретатора. В CPython тип `float` соответствует типу `double` в C. 

**Комплексные числа**

Тип `complex` содержит пару числе с типом `float`. 

```python
c = complex(1, 2)
print(c) # (1+2j)
```

Комплексное число можно создать с помощью литерала:

```python
c = 3+5j
print(type(c)) # <class 'complex'>
```

Реальная и мнимая часть комплексного числа доступна как свойства объекта:

```python
c = complex(1, 2)

print(c.real) # 1.0
print(c.imag) # 2.0
```

#### Последовательности

Последовательности это конечные упорядоченные коллекции объектов. Последовательности индексируются целыми числами, в Python допустимо использование отрицательных индексов. Последовательности делятся на две категории: изменяемые и неизменяемые.

##### Неизменяемые последовательности

Неизменяемые последовательности — это коллекции ссылки на объекты в которых не изменяются после создания. В неизменяемой последовательности может быть ссылка на изменяемый объект, в этом случае значение этого изменяемого объекта может манятся, но сама ссылка на этот изменяемый объект навсегда зафиксирована в неизменяемой последовательности.

Например, кортеж (неизменяемая последовательность) содержит список (изменяемая последовательность). Можно изменять элементы входящие в список. Но нельзя поместить в кортеж ссылку на другой список.

```python
t = [1, 2, 3], "obi", "ike"
print(type(t)) # <class 'tuple'>

t[0].append(4) # изменяем список
print(t) # ([1, 2, 3, 4], 'obi', 'ike')

t[0] = [] # попытка изменить ссылку внутри кортежа
# Traceback (most recent call last):
#   File "test.py", line 7, in <module>
#     t[0] = [] # попытка изменить ссылку внутри кортежа
# TypeError: 'tuple' object does not support item assignment
```

Встроенные неизменяемые последовательсти:

* Строки (Strings)
* Байты (Bytes)
* Кортежи (Tuples)

**Strings**

Строки это неизменяемая последовательность символов (точнее Unicode code points). В Python нет отдельного типа для символов, так что символ это просто строка длины 1. Строки в Python могут предствлять все Unicode code points в диапазоне `U+0000 - U+10FFFF`. Для хранения строк используется тип `str`.

```python
print(type('Hello')) # <class 'str'>
```

**Bytes**

Объект типа `bytes` это неизменяемая последовательность 8-битных байт. Каждый байт представлен в виде целого числа от 0 до 255. Литерал вида `b'abc'` и встроенная функция `bytes()` используются для создания объекта Bytes. 

Bytes тесно взаимодействует со строками. Строки внутри представляют собой последовательность байт декодированную с помощью кодировки (например UTF-8). Символы строк могут быть закодированы с помощью разных кодировок в разные последовательности байт.

```python
b = b'abc'
print(b) # b'abc'

print(type(b)) # <class 'bytes'>

# кодирование строки в байты используя кодировку UTF-16
b = bytes('abc', 'utf-16') 
print(b) # b'\xff\xfea\x00b\x00c\x00'


print(b.decode("utf-16")) # 'abc'
print(type(b.decode("utf-16"))) # <class 'str'>

# декодирование строки неудачно, 
# так как символы закодированы в другой кодировке
print(b.decode("utf-8")) 
# Traceback (most recent call last):
#   File "test.py", line 13, in <module>
#     print(b.decode("utf-8")) 
# UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

**Tuple**

Кортеж это последовательность произвольных объектов. Кортеж из двух и более элементов создаётся списком выражений разделённых запятыми. Кортеж из одного элемента создаётся выражением с последующим за ним запятой. Пустой кортеж создаётся пустой парой круглых скобок.

```python
names = "Obi",
print(names) # ('Obi',)
print(type(names)) # <class 'tuple'>

names = () # tuple of 0
print(names)  # ()
print(type(names))  # <class 'tuple'>

names = "Obi", "Ike", 1 # tuple of 2 or more
print(names)  # ('Obi', "Ike", 1)
print(type(names))  # <class 'tuple'>
```

##### Изменяемые последовательности

Значения внутри изменяемых последовательностей могут менятся после создания объекта. Существует два встроенных типа изменяемых последовательностей: массив байт и список.

**Byte Arrays**

Объект `bytearray` это изменяемый массив байт. Он создайтся встроенной функцией `butearray()`.  Кроме того что `bytearray` изменяемый и следовательно нехешируемый он поддерживает тот же интерфейс и функциональность что и неизменяемый `bytes`.  Массив байт наиболее полезен когда требуется эффективность обеспечиваемая его изменяемостью. Например, при приёме неизвестного количество данных по сети, `bytearra` более эффективен так как может быть расширен при приёме новых данных без создания нового объекта как было бы с неизменяемый `bytes`.

**List**

Список это произвольная последовательность объектов Python, это самый широко используемый тип данных в Python. Списки создаётся выражениями разделёнными запятыми в квадратных скобках. Пустой список создаётся парой пустых квадратных скобок. Список может быть создан из любого перечисляемого типа, помещением его в метод `list()`. 

##### Операции с последовательностями

Типы последовательностей поддерживают общий набор операций. Эти операции описаны в таблице ниже.

* x — объект
* s, t — последовательности
* n, i, j, k — целые числа



| Операция | Описание |
| -------- | -------- |
| x **in** s | **True** если `s` содержит элемент равный `x`, **False** если не содержит |
| x **not in** s | **False** если `s` содержит элемент равный `x`, **True** если не содержит |
| s + t | Соединение последовательностей `s` и `t` |
| s * n | `n` поверхностных копий `s` соединённых в одну последовательность |
| s[i] | i-тый элемент `s`, стартовый — 0 |
| s[i:j] | Срез элементов начиная с `i` (включительно) и заканчивая `j` (не включительно) |
| s[i:j:k] | Срез элементов начиная с `i` (включительно) и заканчивая `j` (не включительно) с шагом `k` |
| len(s) | Длина `s` |
| min(s) | Наименьший элемент из `s` |
| max(s) | Наибольший элемент из `s` |
| s.index(x) | Индекс первого появления элемента `x` в `s` |
| s.count(x) | Количество вхождений `x` в `s` |

**Примечание**

Значения `n` равные или меньшие 0 производят пустую последовательность того же типа:

```python
x = "obi"
s = x*-2
print(s) # ''
print(type(s)) # <class 'str'>
```

Оператора `*` осуществляет поверхностное копирование: вложенные структуры не копируются. Это может привести к проблемам, например при попытке копирования вложенного списка:

```python
lists = [[]] * 3 # поверхностное копирование
print(lists) # [[], [], []] все три копии ссылаются на один лист

lists[0].append(3)
print(lists) # [[3], [3], [3]]
```

Список списков можно сделать другим методом:

```python
lists = [[] for i in range(3)]
lists[0].append(3)
lists[1].append(5)
lists[2].append(7)

print(lists) # [[3], [5], [7]]
```

При отрицательном индексе `i` отчёт начинается с конца строки: будет возвращён элемент под индексом `len(s) + i`:

```python
a = ['a', 'b', 'c', 'd']

print(a[-3]) # b
print(a[1])  # b
```

Соединение неизменяемых последовательностей, таких как строки, всегда возвращает новый объект:

```python
name = "Obi"
print(id(name)) # 19428608

name += "Obi" + " Ike-Nwosu"
print(id(name)) # 19375168
```

Python определяет интерфейсы (это самое близкое слово которое мы можем использовать) `Sequences` и `MutableSequences` в библиотеке `collections`. Они определяют все методы которые должны реализовывать изменяемые и неизменяемые последовательности. При разговоре об абстрактных классах, мы рассмотрим эту концепцию детальнее.

##### Множества

Множества это неупорядоченные, конечные коллекции уникальных объектов. Множества неупорядочены, поэтому не могут быть проиндексированы целыми числами. Элементы множества должны быть хешируемы, а следовательно неизменяемы. Хеширование элементов обязательно так как множества в Python реализуются через хеш-таблицы.

Множества Python поддерживают эффективную проверку наличия объекта во множестве, вычисления пересечений, объединений и разности множеств. Элементы множества можно перебирать и функция `len()` возвращает количество элементов множества. Существует два типа множеств: изменяемые (`set`)  и неизменяемые (`frozenset`). Общие методы множеств представлены в следующей таблице:

| Метод                                    | Описание                                                     |
| ---------------------------------------- | ------------------------------------------------------------ |
| len(s)                                   | Возвращает мощность множества                                |
| x **in** s                               | Проверяет является ли `x` элементом `s`                      |
| x **not in** s                           | Проверяет что `x` не является элементом `s`                  |
| disdisjoint(other)                       | Возвращает **True** если множества не имеют общих элементов. Множества являются непересекающимися (disjoint) тогда и только тогда когда их пересечение равно пустому множеству. |
| issubset(other),  set <= other           | Проверяет что каждый элемент из множества есть в другом множестве. |
| set < other                              | Проверяет что множество является строгим подмножеством другого множества (`set <= other` и `set != other`). |
| issuperset(other), set >= other          | Проверяет что каждый элемент в другом множестве есть в текущем множестве. |
| set > other                              | Проверяет что другое множество является строгим подмножеством текущего множества (`set >= other` и `set != other`). |
| union(other, …), set \| other …          | Возвращает новое множество — объединение текущего и указанных множеств. |
| intersection(other, …), set & other & …  | Возвращает новое множество — пересечение текущего и указанных множеств. |
| difference(other, …), set - other - …    | Возвращает новое множество с элементами из текущего множества (`set`) которых нет в другом множестве (`other`) |
| symmetric_difference(other), set ˆ other | Возвращает новое множество с элементами которые есть в текущем множестве (`set`) или в другом множестве (`other`) но не в обоих сразу. |
| copy()                                   | Возвращает поверхностную копию множества.                    |



`frozenset` — класс неизменяемого множества конструктор. Неизменяемое множество хешируется, поэтому может использоваться как элемент другого множества или ключ словаря.

`set` — класс изменяемого множества. Изменяемое множество нехешируемо и не может быть элементом другого множества. Изменяемое множество может быть создано с помощью фигурных скобок `{}`. Специфичные методы для изменяемого множества:

| Метод                                           | Описание                                                     |
| ----------------------------------------------- | ------------------------------------------------------------ |
| update(other, …), set \|= other \| …            | Обновляет множество, добавляет элементы из других множеств (`other`) |
| intersection_update(other, …), set &=other & …  | Обновляет множество, сохраняет только те элементы которые есть в текущем множестве и во всех других множества. |
| difference_update(other, …), set -= other \| …  | Обновляет множество, удаляет из текущего множество элементы которые есть в других множествах |
| symmetric_difference_update(other), setˆ= other | Обновляет множество, сохраняет только те элементы которые есть в одном из множество но не одновременно в обоих. |
| add(elem)                                       | Добавляет элемент в множество                                |
| remove(elem)                                    | Удаляет элемент из множества. Генерирует исключение `KeyError` если элемента нет в множестве. |
| discard(elem)                                   | Удаляет элемент из множества если он есть в множестве.       |
| pop()                                           | Удаляет и возвращает произвольный элемент из множества. Генерирует исключение если множество пустое. |
| clear()                                         | Удаляет все элементы из множества.                           |

##### Отображение

Отображения в Python это конечные множества объектов (значений) индексированные по неизменяемым объектам (ключам). Ключи в отображении должны быть хешируемы поэтому для ключей исключаются изменяемые типы такие как списки, изменяемые множества, другие отображения.

Выражение `a[k]` возвращает элемент отображения `a` под индексом `k`. Это выражение можно использовать для присваивания или оператора `del`.  Словарь является единственным встроенным типом отображений в Python.

Словари создаются последовательностью пар `ключ: значение` разделённых запятыми в фигурных скобках (`{'name': "obi", 'age': 18}`) или функцией `dict()`. 

Основные операции со словарём: добавление, удаление и выбор значений по данному ключу. При добавлении ключа который уже есть в словаре старое значение с которым был ассоциирован ключ теряется. Попытка доступа к значению по несуществующему ключу генерирует исключение `KeyError`. 

Словари являются одним из самых важных типов внутри интерпретатора. Например, пространства имён реализуются через словари: всякий раз когда в программе используется имя, доступ к объекту происходит через словарь. Объекты в своей реализации тоже используют словарь — все атрибуты объекта хранятся в словаре `__dict__`. 

Python поддерживает расширенные формы словаря в библиотеке `collectons`: упорядоченный словарь и `deafaultdict`. 

`OrderedDict` сохраняет порядок ключей к котором они были добавлены.

`defaultdict` вызывает фабричную функцию когда получаемое из словаря значение не существует. Полученное значение сохраняется в словаре и возвращается как результат:


```python
from collections import defaultdict

d = defaultdict(int)

print(d) # defaultdict(<class 'int'>, {})

print(d[7]) # 0
print(d) # defaultdict(<class 'int'>, {7: 0})
```

##### Вызываемый тип

Этот тип поддерживает операцию вызова функции. Операция вызова функции использует круглые скобки `()` после имени типа. В примере ниже функция обвялена `print_name`, операция вызова функции это когда после имени функции появляются скобки `print_name()`.

```python
def print_name(name):
    print(name)
```

Функции не единственные вызываемые типы в Python. Любой объект реализующий специальный метод `__call__` является вызываемым типом. Функция `callable(type)` используется для проверки того что тип вызываемый. 

Встроенные вызываемые типы Python:

* Встроенные функции.
* Определяемые пользователем функции.
* Методы — функции определяемые внутри классов. Методы делятся на методы экземпляров, статические и классовые методы.
* Классы также вызываемые типы. Создание нового объектах происходит через вызов класса (например, `Foo()`).

Каждый из этих типов описан детальнее в следующих главах.

##### Пользовательские типы

Пользовательские типы создаются выражением `class`.  Пользовательские классы имеют тип `type`:

```python
class Foo:
    pass

print(type(Foo)) # <class 'type'>
```

Подробнее пользовательские типы описаны в главе про объектно-ориентированное программирование.

##### Модули

Модули это один способ организовывать код Python, такой же как функции и классы. Модули это объекты, так же как и любое другое значение в Python. Типы модулей создаются системой импорта через команду `import` или вызовом функций `importlib.import_module()` и `import()`.

##### Файловый типы

Объект `file` представляет открытый файл. Встроенная функция [open](https://docs.python.org/3/library/functions.html#open) открывает файл и возвращает объект `file`. Файл может быть открыт в текстовом или бинарном режиме.

Другой способ открытия файла: функция `os.open` создаёт файловый дескриптор, а функция   `os.fdopen` принимает файловый дескриптор и создаёт файловый объект:

```python
import os

fd = os.open("test.txt", os.O_RDWR|os.O_CREAT)

print(type(fd)) # <class 'int'>
print(fd) # 3


fo = os.fdopen(fd, "w")

print(fo) # <_io.TextIOWrapper name=3 mode='w' encoding='UTF-8'>
print(type(fo)) # <class '_io.TextIOWrapper'>
```

Метод `makefile()` объекта `socket` открывает и возвращает объект `file` ассоциированный с сокетом.  

Встроенные объекты `sys.stdin`, `sys.stdout` и `sys.stderr` так же файловые объекты соответствующие стандартным в Python потокам ввода, вывода и ошибок.

##### Встроенные типы

Эти объекты использовуются внутри интерпретатора, но достпны пользователю программы. Они включают в себя объекты: трассировка (`traceback`), код  (`code`), фрейм (`frame`), срез (`slice`).

###### Объект `code`

Объект `code` представляет скомпилированный запускаемый код Python, или байткод. Объект `code` это машинный код для виртуальной машины Python вместе со всем что нужно для его запуска. Такие объекты создаются при компиляции блока кода. Эта запускаемая часть кода может быть запущена функциями `exec` или `eval`. Для лучшего понимания объекта `code` проанализируем этот объект для простой функции:

```python
def return_author_name():
    return "obi Ike-Nwosu"
```

Доступ к объекту `code` через объект функции происходит через аттрибут `__code__`:

```pyhon
def return_author_name():
    return "obi Ike-Nwosu"

print(return_author_name.__code__) 
# <code object return_author_name at 0x00A6D1C0, file "test.py", line 1>
```

Рассмотрим аттрибуты объекта `code`:

```python
print(dir(return_author_name.__code__))
# ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename', 'co_firstlineno', 'co_flags', 'co_freevars', 'co_kwonlyargcount', 'co_lnotab', 'co_name', 'co_names', 'co_nlocals', 'co_posonlyargcount', 'co_stacksize', 'co_varnames', 'replace']
```

Интерес представляют неспециальные методы — методы которые не начинаются с подчеркивания. Краткое описание этих методов дано в таблице:

| Метод          | Описание                                                     |
| -------------- | ------------------------------------------------------------ |
| co_argcount    | Количество аргументов (не включая аргументы `*` или `**`)    |
| co_code        | Строка с байт-кодом                                          |
| co_consts      | Кортеж констант используемых в байт-коде                     |
| co_filename    | Название файла в котором создан объект `code`                |
| co_firstlineno | Номер первой строки в файле исходного кода                   |
| co_flags       | Битовая карта: 1 = optimized \| 2=newlocals \| 4 = `*arg` \| 8=`**arg` |
| co_lnotab      | Закодированное отображение номера строки кода в индекс байт-кода |
| co_name        | Имя с которым объект `code` был определён                    |
| co_names       | Кортеж имён локальных переменных                             |
| co_nlocals     | Количество локальных переменных                              |
| co_stacksize   | Требуемое количество места на стеке виртуальной машины       |
| co_varnames    | Кортеж имён аргументов и локальных переменных                |



Рассмотрим байт-код функции:

```python
print(return_author_name.__code__.co_code )
# b'd\x01S\x00'
```

Такой байт-код обычно бесполезен для исследования объекта `code`. Модуль `dis` генерирует человекочитаемое представление объекта `code`:

```python
import dis

s = dis.dis(return_author_name)
```

```
  2           0 LOAD_CONST               1 ('obi Ike-Nwosu')
              2 RETURN_VALUE
```

Инструкция `LOAD_CONST` читает значение из кортежа `co_const` и помещает его в стек (интерпретатор CPython это стековая виртуальная машина). Инструкция `RETURN_VALUE` забирает значение из вершины стека и возвращает его в вызвавшее блок кода окружение и сигнализирует об окончании выполнения.

Объекты `code` служат нескольким целям при программировании. Они содержат информацию помогающую при интерактивной отладке и предоставляют читаемые трассировки при исключениях.

###### Объект `frame`

Frame objects represent execution frames. Python code blocks are executed in execution frames. The call stack of the interpreter stores information about currently executing subroutines and the call stack is made up of stack frame objects. Frame objects on the stack have a one-to-one mapping with subroutine calls by the program executing or the interpreter. 

Объекты `Frame` представляют кадры выполнения. Блоки кода Python выполняется в кадрах выполнения. Стек вызовов интерпетатора хранит информацию о текущей выполняемых подрограммах и состоит из стека объектов `Frame`. Объекты `Frame` на стеке однозначно отображаются на вызовы подпрограмм.

`Frame` содержит объект `code` и всю необходимую информацию, включя ссылка на локальное и глобальное пространство имён, необходимое для среды времени выполнения.

Для формирования стека вызовов объекты `Frame` ссылаются друг на друга. Каждый раз когда вызывается подпрограмма, создаётся объект `Frame`, добавляется к стеку и затем запускается объект `code` который он содержит.

Атрибуты объекта `Frame` только для чтения:

| Атрибут                           | Описание                                               |
| --------------------------------- | ------------------------------------------------------ |
| f_back                            | Предыдущий фрейм, или `None` если текущий фрейм нижний |
| f_code`    | Объект `code` фрейма |                                                        |
| f_locals                          | Словарь для поиска локальных переменных                |
| f_globals                         | Глобальные переменные                                  |
| f_builtins                        | Встроенные имена                                       |
| f_lasti                           |                                                        |

Атрибуты поддерживающие запись:

| Атрибут  | Описание                                                     |
| -------- | ------------------------------------------------------------ |
| f_trace  | Если не `None`, то функция отсюда будет вызвана в начале каждой строки кода |
| f_lineno | Номер текущей строки фрейма. Запись в этот метод позволяет перейти на данную строку кода. Работает только для самого верхнего фрейма. Отладчик может реализовать команду `jump` записывая в свойство `f_lineno` |

Объект `Frame` поддерживает один метод `feame.clear()` для очистки ссылок на локальные переменные. Если фрейм принадлежит генератору, то генератор финализируется. Этот метод помогает удалить циклические ссылки с участием объекта `Frame`. Если фрейм сейчас запущен то генерируется исключение `RuntimeError`. 

###### Объект Traceback

Объект `Traceback`представляют трассировку стека исключения. `Traceback` создаётся при возникновении исключения. Интерпретатор ищет обработчик исключения последовательно доставая фреймы выполнения (`Frame`) и вставляя новый объект `Traceback` перед текущим объектом `Traceback` для каждого диктуемого фрейма. Когда встречается обработчик исключения, трассировка стека становится доступны программе.

Объект `Traceback` доступен третьим элементом кортежа возвращаемым `sys.exc_info()`. Когда программа не содержит подходящего обработчик исключений, трассировка стека выводится в стандартный поток ошибок. Если интерпретатор запущен в интерактивном режиме, то последняя трассировка доступна через `sys.last_traceback`. Несколько важных атрибутов `Traceback` представлены в таблице:

| Метод     | Описание                                                     |
| --------- | ------------------------------------------------------------ |
| tb_next   | Следующий уровень в трассировке стека (по направлению к фрейму где произошло исключение). `None` если следующего уровня нет. |
| tb_frame  | Фрейм текущего уровня                                        |
| tb_lineno | Номер строки на которой возникло исключение                  |
| tb_lasti  | Указывает на точную инструкцию. Номер строки и последняя инструкция может отличаться от номера строки фрейма если исключение возникло в блоке `try` без подходящего обработчика или с `finally`. |

###### Объект Slice

Объект `Slice` представляет срез для метода `__getiter__()` последовательностей. Срезы используются для получения подпоследовательностей.

```python
t = [i for i in range(10)]

print(t) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(t[:10:2]) # [0, 2, 4, 6, 8]
```

They are also created by the built-in slice([start,], stop [,step]) function. The returned object
can be used in between the square brackets as a regular slice object.

Срез так же можно создать встроеннй функцией `slice([start,], stop [,step])`: 

```python
t = [i for i in range(10)]

print(t) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(t[:10:2]) # [0, 2, 4, 6, 8]

s = slice(None, 10, 2)
print(s) # slice(None, 10, 2)
print(t[s]) # [0, 2, 4, 6, 8]
```
Атрибуты объекта `Slice`:

| Атрибут | Описание                         |
| ------- | -------------------------------- |
| start   | Нижняя граница                   |
| stop    | Верхняя граница (необязательное) |
| step    | Величина шага (необязательное)   |

Каждый из необязательных аргументов равен `None` если пропущен. У среза есть несколько форм в дополнение к стандартной форме:

```python
# элементы начиная с start и заканчивая end-1
# эквивалентно slice(start, stop)
a[start:end] 

# элементы начиная с start и заканчивая последним индексом последовательности
# эквивалентно slice(start)
a[start:]

# элементы начиная с начала последовательности по end-1
# эквивалентно slice(None, end)
a[:end]

# поверхностная копия последовательности
# эквивалентно slice(None, None)
a[:]
```

Значения `start` и `end` могут быть отрицательными, что означает отчет с конца последовательности:

```python

# последния элемент последовательности
# эквивалентно slice(-1)
a[-1] 

# последние два элемента последовательности 
# эквивалентно slice(-2)
a[-2:]

# всё исключая два последних элемента последовательности 
# эквивалентно slice(None, -2)
a[:-2] 
```

Единственный метод `slice.indices(self, length)` принимает длину и возвращает кортеж из трёх чисел `(start, stop, step)`. Кортеж означает то как срез пименяется к данной длине.

```python
s = slice(10, 30, 1)

# применение slice(10, 30, 1) к последовательности длины 100 возвращает [10:30]
print(s.indices(100)) # (10, 30, 1)


# применение slice(10, 30, 1) к последовательности длины 15 возвращает [10:15]
print(s.indices(15)) # (10, 15, 1)


# применение slice(10, 30, 1) к последовательности длины 1 возвращает [1:1]
print(s.indices(1)) # (1, 1, 1)
print(s.indices(0)) # (0, 0, 1)
```

###### Объект `Generator`

Генераторы создаются при вызове функций генераторов (функции использующие ключеве слово `yield`). Этот тип обсуждается детальнее в главе Последовательности и генераторы.

После знакомства с иерархией встроенных типов, пришло время изучить глубже объектно-ориентированное программирование и способы создания своих иерархий и даже классов похожих похожих поведением на встроенные типы.


## 6. Объектно-ориентированное программирование

Классы это основа объектно-ориентированного программирования в Python и один из базовых способов организации кода в программе.

### 6.1 Механика определения классов

Оператор `class` описывает новый тип и определяет набор атрибутов, переменных и методов которые ассоциируются и разделяются между всеми объектами (экземплярами) этого класса. Определение простого класса:

```python
class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return self.balance
```

Оператор `class` определяет объекты классов, объекты экземпляров и объекты методов.

####  Объекты классов

Запуск оператора `class` создает объект класса. В начале запуска оператора `class` создаётся новое пространство имён в которое добавляются все атрибуты класса. В отличии от языков таких как Java, это пространтсов имен не создаёт новую локальную область видимости в методах класса, поэтому нужно исползовать полное имя при указании атрибутов класса.

Если в методе `__init__` вмето полного имени `Account.num_accounts` попытаться использовать `num_account` то будет сгенерировано исключение:

```python

class Account(object):
    num_accounts = 0

    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        num_accounts += 1

    def del_account(self):
        Account.num_accounts -= 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return self.balance


acct = Account('obi', 10)

# Traceback (most recent call last):
#   File "test.py", line 23, in <module>
#     acct = Account('obi', 10)
#   File "test.py", line 8, in __init__
#     num_accounts += 1
# UnboundLocalError: local variable 'num_accounts' referenced before assignment
```

В конце выполнения оператора `class` создаётся объект класса. Область видимости предшествующая определению класса восстанавливается и объект класса становится доступным в ней под именем данным в заголовке определения класса.

Объект класса, как и любой другой объект Python, является экземпляром определённого класса. Класс для объектов классов называется `type`. 

```python
print(type(Account)) # <class 'type'>
```

Для того чтобы лучше понять что это означает, рассмотрим глубже последовательность действий при выполнении оператора `class`:

```python
class_name = "Account"
class_parents = (object,)
class_body = """
num_accounts = 0

def __init__(self, name, balance):
    self.name = name
    self.balance = balance
    num_accounts += 1

def del_account(self):
    Account.num_accounts -= 1

def deposit(self, amt):
    self.balance = self.balance + amt

def withdraw(self, amt):
    self.balance = self.balance - amt

def inquiry(self):
    return self.balance
"""

# новый словарь используется для локального пространства имён
class_dict = {}

# тело класса запускается с использованием словаря как локального пространства имён
exec(class_body, globals(), class_dict)

# словарь класса содержит связанные имена из тела класса
print(class_dict)
# {'num_accounts': 0, '__init__': <function __init__ at 0x036261D8>, 'del_account': <function del_account at 0x03626190>, 'deposit': <function deposit at 0x03626148>, 'withdraw': <function withdraw at 0x03626100>, 'inquiry': <function inquiry at 0x036260B8>}

# последний шаг создания класса
Account = type(class_name, class_parents, class_dict)

# рассмотрим созданный объект класса
print(Account) # <class '__main__.Account'>
print(type(Account)) # <type 'type'>
```

В течении выполнения оператора `class` интерпритатор выполняет следующую последовательность шагов (очень упрощенно):

1. Тело класса изолируется в объект `code`.
2. Создаётся словарь представляющй пространство имён для создаваемого класса.
3. Объект `code` представляющий тело класса запускается в пронстрансве имён.
4. В течении последнего шага, объект класса создаётся как экземпляр класса `type`, используя имя класса, родительский класс и словарь класса как аргументы. Класс `type` используемый для создания классов это мета-класс, класс классов. Мета-класс используемый при создании объекта класса может быть явно задан с помощью ключевого слова `metaclass` при определении класса. Если это слово не используется то базовые классы проверяются на использование мета-классов. Если базовые классы их не используют то применяется мета-класс по умочанию `type()`. Детальнее о мета-класса рассказано в последующих главах.

Объект класса поддерживает ссылки на атрибуты и создание объектов. На атрибуты ссылаются стандартным синтаксисом, через точку: имя объекта, затем точка, затем имя отрибута (`obj.name`). Все имена переменных и методов представленных в пространстве имён класса являются допустимыми именами атрибутов когда объекта класса создан.

```python
print(Account.num_accounts) # 0
print(Account.deposit) # <function Account.deposit at 0x00E46148>
```

Обекты создаются вызовом объекта класса, как обычной функции. Пераметры функции совпадают с параметрами метода `__init__`:

```python
>>> Account("obi", 0)
```

#### Объекты экземпляров

Объекты классов создают объекты экземпляры классов. Ссылки на атрибуты являются единственными возможными операциями для экземпляров объектов. Атрибуты делятся на два вида: атрибуты данных (переменные экземпляра) и атрибуты методов.

#### Объекты методов

Если `x` это экземпляр класса `Account`, то `x.deposit` это пример метода объекта. Метод объекта похож на функцию, однако в определение метода, включается дополнительный аргумент `self`.  Этот аргумент ссылается на экземпляр класса, но нам не требуется передавать его в явном виде:

```python
x = Account()
x.inquiry()
```

Вызов `x.inquiry()` эквивалентен вызову `Account.inquiry(x)`. Объект экземпляра `x` передаётся первым аргументом метода. Вызов метода объекта со списком аргументов эквивалентен вызову метода класса объекта с тем же список аугментов вместе с самим объектом переданным как первый аргумент. Методы хранятся просто как функции в словаре класса:

```python
print(type(Account.inquiry)) # <class 'function'>
```

Метод методы объектов это обёртка вокруг объектов функций. Когда вызывается метод объекта со списком аргументов, создаётся новый список аргументов вместе с экземпляром объекта. Исходный объект функции вызывается новым списком аргументов. Это применяется ко всем метода экземпляров объектов, включая метод `__init__`. 

Аргумент `self` не является зарезервированным словом, имя `self` просто принято в сообществе. Любое корректное имя аргумента может использоваться вместо него:

```python
class Account(object):
    num_accounts = 0

    def __init__(obj, name, balance):
        obj.name = name
        obj.balance = balance
        Account.num_accounts += 1

    def del_account(obj):
        Account.num_accounts -= 1

    def deposit(obj, amt):
        obj.balance = obj.balance + amt

    def withdraw(obj, amt):
        obj.balance = obj.balance - amt

    def inquiry(obj):
        return obj.balance


print(Account.num_accounts) # 0

x = Account('obi', 0)
x.deposit(10)
print(Account.inquiry(x)) # 10
```

Далее в этой главе будут описаны дескрипторы и алгоритм ссылок на атрибуты, которые позволят лучше понять эту трансформацию. 