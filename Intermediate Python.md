% Intermediate Python
% Obi Ike-Nwosu
% leanpub.com, 2016

# Intermediate Python

Перевод книги [Intermediate Python](https://leanpub.com/intermediatepython) Obi Ike-Nwosu. Перевод выполнен с сокращениями, часть текста и примеры изменены.

## 1. Благодарности

Текст с благодарностями автора оригинального издания без корректировок.

I would love to take the opportunity to thank all who have reviewed and spotted issues in the manuscript. This includes but is not limited to Ngozi Nwosu for taking the time out to review the whole manual and point out a whole load of grammatical errors, Olivia Enewally, Roman Turna and Abhen Ng for pointing out some factual and grammatical errors.A whole lot of other people on Reddit have pointed out errors and to those people I am really grateful. 

Without the input of all these people, this manuscript would be worth less than it currently is. Thank you all!

## 2. Введение

Эта книга рассчитана на средний уровень знакомства с Python. В качестве интерпретатора подразумевается [CPython](https://www.python.org/). [Документация](https://docs.python.org/3/reference/index.html) последней стабильной версии.

## 3. Очень короткий учебник

Этот короткий учебник раскрывает основные концепции и возможности языка программирования Python.

### 3.1 Использование Python

Python установлен по умолчанию на Unix-системах. Для проверки установлен ли Python, откройте командную строку и введите `python`. Если Python не установлен то откройте [сайт Python](https://www.python.org/) и следуйте инструкциям для вашей платформы.

Если после установки Python не запускается из командной строки, проверьте добавлен ли путь к интерпретатору в системные пути.

Запуск интерпретатора командой `python` начинает интерактивную сессию [REPL](https://ru.wikipedia.org/wiki/REPL). Основная подсказка `>>>` предлагает ввести команду, вторичная подсказка `...` сигнализирует о продолжении предыдущей инструкции:

```python
>>> def hello():
...     print("Hello world")
...
>>>
```

Пользователь вводит инструкции python и немедленно получает ответ. В режиме REPL Python может использоваться как продвинутый калькулятор:

```python
Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:21:23) [MSC v.1916 32 bit (In
tel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> a = 3
>>> b = 3
>>> a * b + 5
14
>>>
```

Введите Ctrl+Z для завершения сессии интерпритатора.

### 3.2 Операторы Python, строки и отступы

Программа на Python состоит из логических строк ограниченных токеном **NEWLINE**. Каждая логическая строка эквивалентна простому оператору. Составные операторы формируются из нескольких логических строк.

Логическая строка создаётся из одной или нескольких физических строк используя явные или не явные правила объединения строк. Физическая строка — это последовательность символов завершающаяся символами перевода строки (end-of-line sequence). Python неявно рассматривает физические строки как логические, устраняя необходимость в точке с запятой для разделения выражений. Однако точка с запятой может использоваться для разделения одной физической строки на несколько логических:

```Python
>>> i = 5; print i;
5
```

Несколько физических строк в явном виде объединяются в одну логическую символом "\\":

```Python
>>> name = "Obi Ike-Nwosu"
>>> cleaned_name = name.replace("-", " "). \
... replace(" ", "")
>>> cleaned_name
'ObiIkeNwosu'
>>>
```

Физические строки соединяются неявно, без использования символа продолжения строки ("\\"), когда выражение находится в тройных строковых кавычках, заключено в скобки `(...)`, `[...]`, или `{...}`.

Python содержит два типа операторов.

Простые операторы занимающие одиночные логические строки. Они включают в себя присваивание, **yield** и др. Общий синтаксис простых операторов:

```
simple_stmt ::= expression_stmt
            | assert_stmt
            | assignment_stmt
            | augmented_assignment_stmt
            | pass_stmt
            | del_stmt
            | return_stmt
            | yield_stmt
            | raise_stmt
            | break_stmt
            | continue_stmt
            | import_stmt
            | global_stmt
            | nonlocal_stmt
```

Составные операторы занимающие несколько логических строк. Они включают в себя выражения циклов **while** и **for**. Общий синтаксис составных операторов:

```
compound_stmt ::= if_stmt
              | while_stmt
              | for_stmt
              | try_stmt
              | with_stmt
              | funcdef
              | classdef

suite ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT

statement ::= stmt_list NEWLINE | compound_stmt

stmt_list ::= simple_stmt (";" simple_stmt)* [";"]
```

Составные операторы содержат одно или несколько предложений (clause). Предложение состоит из заголовка (header) и тела (suite). Заголовки предложений для одного составного оператора имеют одинаковый отступ и начинаются с уникального идентификатора (**while**, **if** и т.д.) и с двоеточия. Составной оператор **if** определяется так:

```
if_stmt ::=  "if" expression ":" suite
             ( "elif" expression ":" suite )*
             ["else" ":" suite]
```

Выполнение тела предложения контролируется заголовком:

```Python
>>> num = 6
# оператор if является составным оператором
    # Заголовок предложения контролирует выполнение следующего блока с отступом
>>> if num % 2 == 0:
        # блок тела с отступом
...     print("The number {} is even".format(num))
...
The number 6 is even
>>>
```

Тело (suite) может быть набором из одного или нескольких операторов который следуют за двоеточием заголовка, в этом случае, операторы разделяются точкой с запятой:

```Python
>>> x = 1
>>> y = 2
>>> z = 3
>>> if x < y < z: print(x); print(y); print(z)
...
1
2
3
```

Но обычно тело (suite) записывается со следующей после заголовка строки в виде одного или нескольких операторов с отступом:

```Python
>>> x = 1
>>> y = 2
>>> z = 3
>>> if x < y < z:
...    print(x)
...    print(y);
...    print(z)
...
1
2
3
```

Отступы используются для обозначения блоков кода таких как тела функций, условий, циклов и классов. Ведущий пробел в начале логической строки используется для вычисления отступа для этой строки, который, в свою очередь, используется для определения группировки оператора. Отступ используемый в теле блока всегда должен совпадать с отступом первого оператора в блоке.

### 3. Строки

Строки в Python обрамляются двойными "..." или одинарными '...' кавычками. Спецсимволы указываются внутри строки с экранированием:

```python
# кавычка используется как апостроф, поэтому мы экранируем её чтобы 
# предотвратить завершение строки
>>> name = 'men\'s'
>>> name
"men's"
>>>
```

Для того чтобы отключить обработку спецсимволов в строке, добавьте перед строкой символ **r**:

```python
>>> print('C:\some\name') # здесь \n означает перевод строки!
C:\some
ame
>>> print(r'C:\some\name') # добавлен r перед кавычкой
C:\some\name
```

Многострочные строковые литералы задаются тройными кавычками. Перевод строки автоматически добавляется при достижении конца строки:

```python
>>> para = """hello world I am putting together a
... book for beginners to get to the next level in python"""
# Обратите внимание на символ перевод строки
>>> para
'hello world I am putting together a \nbook for beginners to get to the next level in python'
# При выводе текст разделяется на несколько срок
>>> print(para)
hello world I am putting together a
book for beginners to get to the next level in python
>>>

Чтобы перевод строки не добавлялся используйте символ **\** в конце строки:

​```python
>>> para = """hello world I am putting together a \
... book for beginners to get to the next level in python"""
>>> para
'hello world I am putting together a book for beginners to get to the next level in python'
>>> print(para)
hello world I am putting together a book for beginners to get to the next level in python
>>>
```

Строки неизменяемые, один раз созданная строка не может быть изменена. Для символов отдельного типа нет, они являются строками длинной в 1 символ. Строки являются одним из типов последовательностей, поэтому поддерживают все операции с последовательностями, за исключением присваивания по индексу из-за неизменяемости. Обращение к отдельному символу происходит по индексу:

```python
>>> name = 'obiesie'
>>> name[1]
'b'
>>>
```

Строки соединяются оператором **+**:

```python
>>> name = 'obiesie'
>>> surname = " Ike-Nwosu"
>>> full_name = name + surname
>>> full_name
'obiesie Ike-Nwosu'
>>>
```

Написанные рядом строковые литералы соединяются автоматически:

```python
>>> 'Py' 'thon'
'Python'
>>>
```

Встроенная функция **len** возвращает длину строки:

```python
>>> name = "obi"
>>> len(name)
3
>>>
```

### 3.4 Управляющие конструкции

#### if-else и if-elif-else

Оператор **if** применяется для условного выполнения блока кода:

```python
>>> name = "obi"
>>> if name == "obi":
...     print("Hello Obi")
...
Hello Obi
>>>
```

За оператором **if** следует ноль или больше операторов **elif** и не обязательный оператор **else**. Если не один из операторов **if** или **elif** не был выполнен, то выполняется блок **else**:

```python
>>> if name == "obi":
...     print("Hello Obi")
... elif name == "chuks":
...     print("Hello chuks")
... else:
...     print("Hello Stranger")
Hello Stranger
>>>
```

#### for и range

В Python два вида циклов: **while** и **for**.

Оператор **for** используется для перебора последовательностей (list, set, tuple и т.д.). В общем случае, цикл **for** используется для перебора любых объектов реализующих протокол итератора Python (python iterator protocol). Подробнее это будет описано в следующих главах.

Пример использования цикла **for**:

```python
>>> names = ["Joe", "Obi", "Chris", "Nkem"]
>>> for name in names:
...     print(name)
...
Joe
Obi
Chris
Nkem
>>>
```

Большинство языков программирования использует синтаксис похожий на этот для перебора последовательности чисел:

```
for(int x = 10; x < 20; x = x+1) {
// do something here
}
```

В Python используется конструкция **range()** для генерации арифметической прогрессии целых чисел:

```python
>>> for i in range(10, 20):
...     print i
...
10
11
12
13
14
15
16
17
18
19
```

Функция range(start, stop, step) допускает три аргумента. Значение параметра **stop** не входит в возвращаемую последовательность.

#### while

Оператор **while** выполняет блок кода пока условное выражение вычисляется в **True**:

```python
>>> counter = 10
>>> while counter > 0: # условное выражение 'counter > 0'
...     print(counter)
...     counter = counter - 1
...
10
9
8
7
6
5
4
3
2
1
```

#### break и continue

Команда **break** завершает выполнение цикла, после **break** происходит немедленный выход из цикла.

```python
>>> for i in range(10):
...     if i == 5:
...         break
...     else:
...         print(i)
...
0
1
2
3
4
```

Команда **continue** принудительно запускает следующую итерацию цикла. Все команды внутри цикла после **continue** игнорируются.

```python
>>> for i in range(10):
        # если i равно 5 то начинаем новую итерацию цикла, без выполнения остальных команд
...     if i == 5:
...         continue
...     print("The value is " + str(i))
...
The value is 0
The value is 1
The value is 2
The value is 3
The value is 4
# no printed value for i == 5
The value is 6
The value is 7
The value is 8
The value is 9
```

В примере выше, значение 5 не напечатано, из-за условия и команды **continue**. Все остальные значения напечатаны.

#### циклы и else 

В Python ключевое слово **else** применяется вместе с операторами цикла. Блок после **else** выполняется если цикл не был завершён оператором **break**.

```python
# loop exits normally
>>> for i in range(10):
...     print(i)
... else:
...     print("I am in quirky else loop")
...
0
1
2
3
4
5
6
7
8
9
I am in quirky else loop
```

Если цикл завершён оператором **break**, то блок **else** пропускается:

```python
>>> for i in range(10):
...     if i == 5:
...        break
...     print(i)
... else:
...     print("I am in quirky else loop")
...
0
1
2
3
4
```

#### Enumerate

Иногда нужно перебрать коллекцию, поучая одновременно индекс и значение элементов. Можно использовать такой подход:

```python
>>> names = ["Joe", "Obi", "Chris", "Jamie"]
>>> name_count = len(names)
>>> index = 0
>>> while index < name_count:
...   print("{}. {}".format(index, names[index]))
...   index = index + 1
...
0. Joe
1. Obi
2. Chris
3. Jamie
```

В Python есть более эффективное решение с функцией **enumerate**:

```python
>>> for index, name in enumerate(names):
...     print("{}. {}".format(index, name))
...
0. Joe
1. Obi
2. Chris
3. Jamie
>>>
```
### 3.5 Функции

Именованные функции определяются ключевым словом **def**, за которым следует название функции и список параметров в скобках. Ключевое слово **return** используется для возвращения значения функции:

```python
def full_name(first_name, last_name):
    return " ".join((first_name, last_name))
```

Для вызова функции используется её имя, параметры передаются в скобках:

```python
full_name("Obi", "Ike-Nwosu")
```

Функции могут вернуть несколько значений в виде кортежа. В следующим примере функция возвращает частное и остаток от деления:

```python
>>> def divide(a, b):
...     return divmod(q, r)
...
>>> divide(7, 2)
(3, 1)
>>>
```

Функция без **return** всегда возвращает **None**:

```python
>>> def print_name(first_name, last_name):
...     print(" ".join((first_name, last_name)))
...
>>> print_name("Obi", "Ike-Nwosu")
Obi Ike-Nwosu
>>> x = print_name("Obi", "Ike-Nwosu")
Obi Ike-Nwosu
>>> x
>>> type(x)
<type 'NoneType'>
>>>
```

Ключевое слово **return** может использоваться без значения чтобы прервать выполнение функции:

```python
>>> def dont_return_value():
...     print("How to use return keyword without a value")
...     return
...
>>> dont_return_value()
```

Выражение **lambda** позволяет объявить функцию без имени. Такая функция состоит всего из одного выражения которое и является значением функции. Поэтому не требуется использовать **return**.


```python
>>> square_of_number = lambda x: x**2
>>> square_of_number
<function <lambda> at 0x101a07158>
>>> square_of_number(2)
4
>>>
```

Функция созданная через **lambda** эквивалентна именованной функции определённой через **def**.

### 3.6 Структуры данных

Python содержит встроенные типы данных: списки, кортежи, словари.

#### Списки

Списки создаются используя квадратные скобки или функцию `list()`:

```python
my_list1 = [] # Пустой список
my_list2 = list() # Пустой список
```

Список сохраняет порядок элементов с которым создаётся или в котором элементы добавляются. Списки являются последовательностями и поддерживают доступ по индексу, другие свойства последовательностей будут описаны в следующих главах. 

Первый элемент списка находится под индексом 0, последний — на единицу меньше длины списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name[0]
'obi'
>>> name[1]
'ike'
>>> name[2]
'nwosu'
```

Метод `append()` добавляет элемент в список.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name.append("nkem")
>>> names
["obi", "ike", "nwosu", "nkem"]
```

Метод `insert()` добавляет элемент в любое место списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name.insert(1, "nkem")
>>> names
["obi", "nkem", "ike", "nwosu"]
```

Оператор `+` позволяет объединить два и более списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name1 = ["James"]
>>> name + name1
["obi", "ike", "nwosu", "James"]
```

Для просмотра всех методов списка запустите команду `help(list)`.

#### Кортежи

Кортеж тоже является последовательностью и создается элементами разделёнными запятыми:

```python
>>> companies = "Google", "Microsoft", "Tesla"
>>> companies
('Google', 'Microsoft', 'Tesla')
```

При определении непустого кортежа скобки не обязательны, но они становятся обязательными когда кортеж является частью большего выражения. Пустой кортеж создаётся пустой парой скобок:

```python
>>> companies = ()
>>> type(companies)
<class 'tuple'>
```
При определении кортежа с одним элементом запятая за ним обязательна.

```python
>>> company = "Google",
>>> type(company)
<class 'tuple'>

>>> company = ("Google",)
>>> type(company)
<class 'tuple'>
```

Пропуск запятой означает что задано обычное значение, не кортеж.

```python
>>> company = ("Google")
>>> company
'Google'

>>> type(company)
<class 'str'>
```

Кортежи индексируются как списки, но неизменямы.

```python
>>> companies = ("Google", "Microsoft", "Palantir")
>>> companies[0]
'Google'
>>> companies[0] = "Boeing"
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

В тоже время, если элементом кортежа является изменяемые объект, такой как список, то он может быть изменен.

```python
>>> companies = (["lockheedMartin", "Boeing"], ["Google", "Microsoft"])
>>> companies
(['lockheedMartin', 'Boeing'], ['Google', 'Microsoft'])
>>> companies[0].append("SpaceX")
>>> companies
(['lockheedMartin', 'Boeing', 'SpaceX'], ['Google', 'Microsoft'])
```

#### Множества

Множества это неупорядоченные коллекции объектов не содержащие дубликатов. Пустое множество создаётся функцией `set()` или круглыми скобками `{}`.  Множества неупорядоченны поэтому к элементам множества нельзя обратится по индексу. Множества, за исключением frozen set, изменяемы.

```python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> basket_set = set()
>>> basket_set
set()
>>> basket_set.update(basket)
>>> basket_set
{'pear', 'orange', 'apple', 'banana'}
>>> basket_set.add("clementine")
>>> basket_set
{'pear', 'orange', 'apple', 'banana', 'clementine'}
>>> basket_set.remove("apple")
>>> basket_set
{'pear', 'orange', 'banana', 'clementine'}
```

#### Словари

Словарь в Python похож на ассоциативный массив или хеш-таблицу в других языках. Словари индексируются по неизменяемому ключу. Для создания словаря используются фигурные скобки `{}` или функция`dict()`. Словарь — неупорядоченное множество пар ключ-значение в которых ключ уникален. Пример инициализации словаря:

```python
ages = {"obi": 24,
"nkem": 23,
"Chris": 23
}
```

Основные операции словаря это сохранение значения по ключу и доступ к значению по ключу. Доступ к значению осуществляется через квадратные скобки:

```python
>>> ages["obi"]
24
```

Словари изменяемы, значения связанные с ключами могут менятся, добавлятся и удалятся.

Структуры данных Python не ограничиваются приведёнными в этом разделе. Например, модуль `collections` содержит очереди, деки и другие коллекции. В то же время структуры приведённые в этом разделе используются в большинстве приложений на Python.

Используйте функцию help с параметром в виде названия типа данных для детального изучения типа.

```python
help(list)
help(tuple)
help(set)
help(dict)
```

### 3.7 Классы

Выражение `class` используется для определения новых типов в Python:

```python
class Account:
    # классовая переменная общая для всех экземпляров классов
    num_accounts = 0

    def __init__(self, name, balance):
    # переменные экзепляра
    self.name = name
    self.balance = balance
    
    # изменение классовой переменной 
    Account.num_accounts += 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)

    @classmethod
    def from_dict(cls, params):
        params_dict = json.loads(params)
        return cls(params_dict.get("name"), params_dict.get("balance"))
```

Классы в Python, как в других языках, могут содержать классовые пеменные, переменные объекта, классовые методы, статичные методы и методы объекта. 

При определении класса, имя родителського класса указывается в скобках после названия класса.

```python
class dog(animal):

```

Метод `__init__` похож на конструктор в других языках программирования. В этом методе инициализируются переменные объекта. Для создания объекта класса `Account` нужно передать аргументы указанные в `__init__` за исключением `self`:

```python
>>> acct = Account("obie", 10000000)
```

Методы обявленные с аргументом `self` являются методами объекта. Аргумент `self` является ссылкой на объект. Методы вызываются через точку:

```python
>>> acct = Account("obie", 10000000)
>>> account.inquiry()
Name=obie, balance=10000000
```

Встроенная функция `dir` предназачена для исследования объектов и печатает все методы, переменные и атрибуты объекта который в неё передан.

### 3.8 Модули

С ростом размера и сложности кода он всё больше нуждается в структуризации. Python позволяет разделить кода на несколько файлов. Каждый файл назвывается модулем имеет расширений `.py`. Для обращения к определениям из файла его необходимо имортировать командой `import`. 

```python
>>> import Account
>>> acct = Account.Account("obie", 10000000)
```

Команда `import` требует имя модуля без расширения `.py`.  При иморте создается пространство имён с именем модуля (в примере `Account`). Доступ к определням из пространства имён осуществляется через точку (`.`).

Ключевое слово `as` задаёт название пространство имён отличное от названия модуля:

```python
>>> import Account as acct
>>> account = acct.Account("obie". 10000000)
```

Возможнен иморт отдельных определений из модуля вместо всего модуля:

```python
>>> from Account import Account
>>> account = Account("obie", 10000000)
```

Возможно импортрровать все опредления из модуля:

>>> from Account import *

Такой способ не рекуомендуется, так как приводит к конфликтам разных пространств имён: импортированные имена из одного модуля перезаписываются импортом из другого.

Модули это обычные объекты Python, их можно исследовать функцией `dir`. Модули могут быть сгруппированы в пакеты. Пакеты и модули детальнее описаны в следующих главах.

### 3.9 Исключения

Python поддерживает исключения и перехват исключений. Например, при делении на ноль интерпритатор выбросит исключение `ZeroDivisionError`.

```python
>>> 2/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>>
```
Во время выполнения программы, исключение генерируется когда происходит ошибка. Если исключение не обработано, то на экран будет выведен стек вызовов. В обычном случае необработанное исключение остановит выполнение программы.

Исключения перехватываются командой `try...catch`:

```python
>>> try:
...     2/0
... except ZeroDivisionError as e:
...     print("Attempting to divide by 0. Not allowed")
...
Attempting to divide by 0. Not allowed
>>>
```
Исключения бывают разных типов. В примере выше обрабатывается исключение `ZeroDivisionError` и если в защищенном коде возникнет другое исключение, то работа программы остановится.

Для перехвата любого исключения тип исключения не указывается

```python
>>> try:
...     2/0
... except:
...     print("Attempting to divide by 0. Not allowed")
...
Attempting to divide by 0. Not allowed
>>>
```
Такая конструкция не рекомендуется, так как невозможно сказать какой тип возникшего исключения.

Для объявления пользовательского типа исключения создаётся класс наследуемый от `Excption`. Пользовательские исключения перехватываются тем же способом что и стандартные.

### 3.10 Ввод и вывод

Python поддерживает операции ввода и вывода из разных источников. Пример чтения файла:

```python
f = open("afile.txt")
line = f.readline()
while line:
    print(line)
    line = f.readline()
```

Метод `open` возвращает объект типа `file` или генерирует исключение если файл не сущетвует. Объект типа `file` поддерживает методы такие как чтение всего файла в строку (`read`) или чтение одной строки файла (`readline`). Python поддерживает синтаксический сахар для перебора всех строк файла:

```python
for line in open("afile.txt"):
    print(line)
```

Пример записи в файл:

```python
f = open("out.txt", "w")
contents = ["I", "love", "python"]
for content in contents:
    f.write(content)
f.close()
```

Python так же поддерживает запись в стандартный поток вывода и чтение из стандартного потока ввода.

```python
name = input('What is your name? ')
print(f'Hello, {name}')
```

### 3.11 Документация

Интерпретатор Python содержит много встроенной документации. Для получения документации используйте команду `help`, в параметре передаётся название класса или онструкции языка.

```python
help('try')
help(list)
```

## 4.  Intermezzo: Глоссарий

В этой книге используются термины и эзотерический функции Python понимание которые является условием глубокого понимания Python. Ниже даётся объяснение этих терминов и функций.

### 4.1 Имена и связывание

В Python, на объекты ссылаются через имена. Имена аналогичны переменным в C++ или Java.

```
>>> x = 5
```

В примере выше, `x` &mdash; имя которое ссылается на объект `5`. Процесс присваивания ссылки на `5` в `x` называется связыванием. Связывание приводит к тому что имя ассоциируется с объектом. 

Связывание происходит в разных ситуациях: при присваивании и при вызове методов, когда параметры связываются с аргументами.

Важная особенность: **имена являются только ссылками без связанного с ними типа; имена ссылаются на объекты которые имеют тип**.

Присваивание создаёт новое имя в самой внутренней области видимости программы: если присваивание выполняется в коде модуля &mdash; имя добавляется в глобальные переменные модуля, если в коде функции &mdash; в локальные переменные функции.

### 4.2 Блоки кода

Блок кода это часть программы запускаемая как одно целое. Модули, функции и класс являются примерами блоков кода. Команды вводимые в REPL скрипты запущенные с опцией `-c` тоже блоки кода. Блок кода содержит пространства имён связанные с ним. Например, блок кода модуль имеет доступ к глобальному пространству имён, а блок кода функция имеет доступ к локальному и глобальному пространству имён.

### 4.3 Пространства имён

Пространство имён — контекст в котором данное множество имён связано с объектами. Сейчас пространства имён реализованы в виде словаря. Например, пространство имён встроенных функций реализуется словарём `__builtins__.__dict__`.

Интерпретатору доступны несколько пространств имён, включая глобальное пространство имён, пространство имён встроенных функций и локальное пространство имён. Эти пространства имён создаются в разное время и имеют разное время жизни. 

Например, локальное пространство имён создаётся при вызове функции и уничтожается при выходе из функции. Глобальное пространство имён создаётся в начале запуска модуля и все имена определённые в нём доступны для всего модуля. Пространство имён встроенных функций создаётся при запуске интерпретатора и содержит все встроенные имена. Эти три основные пространства имён доступные интерпретатору.


### 4.4 Области видимости

Область видимости это часть программы в которой множество имён (пространств имён) видимы и доступны напрямую. Прямой доступ важная характеристика области видимости и будет объяснена при разговоре о классах. В простом смысле, это означает что имя может использовать как есть, без использования точки для доступа к имени, как например `SomeClassOrModule.name`. Во время выполнения следующие области видимости могут быть доступны

1. Самая внутренняя область видимости с локальными именами.
2. Область видимости внешней функции если она есть (для вложенных функций)
3. Глобальная область видимости текущего модуля
4. Пространство имён встроенных функций

При использовании имени интерпретатор ищет в пространствах имён областей видимости в порядке указном выше и если имя не найдено генерирует исключение.

Python поддерживает статическое пространство имён (static scoping,  lexical scoping). Это означает что для определения того какая переменная используется в данном блоке достаточно просмотра текста программы. TODO Link

#### Примечание

Python содержит правила предотвращающие изменение имени в глобальной области видимости из локальной области области видимости. Попытка сделать это приведёт к исключению `UnboundLocalError`.

```python
>>> a = 1
>>> def inc_a(): a += 2
...
>>> inc_a()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 1, in inc_a
UnboundLocalError: local variable 'a' referenced before assignment
```

Для изменения объекта из глобальной области видимости в локальной области видимости применяется ключевое слово `global`. Оно должно использоваться до того как происходит изменение объекта.

```python
>>> a = 1
>>> def inc_a():
...     global a
...     a += 1
...
>>> inc_a()
>>> a
2
```

Ключевое слово `nonlocal` используется при необходимости изменения привязки переменной во внешней не глобальной области видимости из внутренней области видимости. Это полезно во вложенных функциях (замыканиях). Пример использования `nonlocal` при определении объектов-счётчиков: 

```python
>>> def make_counter():
...     count = 0
...     def counter():
...         nonlocal count # nonlocal captures the count binding from enclosing scope not global scope
...         count += 1
...         return count
...     return counter
...
>>> counter_1 = make_counter()
>>> counter_2 = make_counter()
>>> counter_1()
1
>>> counter_1()
2
>>> counter_2()
1
>>> counter_2()
2
```

### 4.5 eval()

Встроенная функция `eval` запускает выражение Python переданное в виде строки или объекта типа `code`. Сигнатура функции:

```python
eval(expression, globals=None, locals=None)
```

При вызове `eval` возвращает результат выражения:

```python
>>> eval("2 + 1") # note the expression is in a string
3
```

Аргумент `globals` должен быть словарём, а `locals` может быть любым отображением. Если `globals` не задан то вместо него используется текущее глобальное пространство имён. Это означает что у кода будет доступ ко всем именам текущего модуля.

```python
def g():
    return 4

print(eval('2 + 2 + g()')) # 8
```

Вместо строки в `eval` можно передать объект типа `code` полученный функцией `compile`.  `eval` и `exec` используется для запуска произвольного Python кода, например, в онлайн интерпретаторах Python.

### 4.6 exec()

`exec` похож на `eval`, он запускает строку (или объект типа `code`) с набором команд Python. Сигнатура `exec`:

```python
exec(object[, globals[, locals]])
```

Пример использования `exec` используя строку и текущее пространство имён:

```python
Python 3.4.2 (v3.4.2:ab2c023a9432, Oct 5 2014, 20:42:22)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.

>>> cont = open('acct.py', 'r').read()

>>> cont
'class Account:\n """base class for representing user accounts"""\n num_accounts = 0\n\n de\
f __init__(self, name, balance):\n self.name = name \n self.balance = balance \n \
Account.num_accounts += 1\n\n def del_account(self):\n Account.num_accounts -= 1\n\n \
def __getattr__(self, name):\n """handle attribute reference for non-existent attribute"""\n \
return "Hey I dont see any attribute called {}".format(name)\n\n def deposit(self, amt):\n\
self.balance = self.balance + amt \n\n def withdraw(self, amt):\n self.balance = s\
elf.balance - amt \n\n def inquiry(self):\n return "Name={}, balance={}".format(self.name,\
self.balance) \n\n'

>>> exec(cont)
# запускаем содержимое файла используя пространство имён по умочанию
>>> Account # теперь мы можем ссылаться на класс Account
<class '__main__.Account'>
>>>
```

Если необязательные аргументы пропущены когда запускается в текущей области видимости. Если задан только `global` то они используется для глобальных и локальных переменных. 

Если словарь переданный в `global` не содержит  ключа `__builtins__` то под этим ключом будет добавлена ссылка на пространство имён встроенных функций. Вставив под ключом `__builtins__` свой словарь можно добиться запрета или ограничения стандартных функций.

## 5. Objects 201

Любое значение в Python является объектом. Любой объект имеет идентификатор, тип и значение. Идентификатор объекта не меняется после создания объекта. 

Функция `id(obj)` возвращает идентификатор объекта. В CPython идентификатор объекта это адрес объекта в памяти. В других реализациях Python идентификатор объекта может генерироваться по другому принципу, но он обязательно должен уникально идентифицировать объект в интерпретаторе.

```python
>>> n = 5
>>> id(5)
1573971952
```

Оператор `is` сравнивает идентификаторы двух объектов и возвращает логическое значение.

```python
>>> n1 = 6
>>> n2 = 7
>>> n1 is n2
False
```

Функция `type()` возвращает тип объекта, тип тоже сам является объектом. Тип объекта, при нормальной работе, неизменяем. Тип объекта определяет операции которые поддерживает объект и возможный набор значений. Python динамический язык программирования потому что типы не связаны с переменными, так что переменная `x` сначала может ссылаться на число, а через некоторое время на строку.

```python
x = 1
x = "Nkem"
```

В тоже время Python является строго типизированным языком, так как интерпретатор не меняет тип объекта автоматически. Это, например, означает что при сложении строки и числа будет сгенерировано исключение:

```python
>>> x = "Nkem"
>>> x + 1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
```

Такое поведение отлично от других языков, например, от JavaScript где интерпретатор неявно конвертирует число в строку и соединит их.

Объекты Python бывают двух типов: изменяемые и неизменяемые.

**Изменяемые объекты**

Значения изменяемых объектов могут меняться. Например, список относится к изменяемым объектам, в него можно добавлять или удалять элементы:

```python
>>> a = [1, 2]
>>> a.append(3)
>>> a
[1, 2, 3]
```

Значения в Python всегда передаются по ссылке, это, в частности, означает что при передачи ссылки на значение в метод (любой объект), внутри метода будет использоваться ссылка на то же значение. Демонстрация такого поведения:

```python
>>> x
[1, 2, 3]
>>> y = x
# теперь x и y ссылаются на один список
>>> x.extend([4, 5, 6])
# изменение в x отражаются в y
>>> y
[1, 2, 3, 4, 5, 6]
```
`x` и `y` ссылаются на один объект поэтому неважно через какую ссылку было произведено изменение объекта. Важно понимать что `x` не содержит список, а только ссылку на него и при присваивании `y = x` в `y` так же помещается только ссылка на тот же самый список.

**Неизменяемые объекты**

Неизменяемые объекты не могут изменить своё значение. Кортежи являются неизменяемыми объектами: 

```python
>>> x = (1, 2, 3, 4)
>>> x[0]
1
>>> x[0] = 10
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>>
```

Неизменяемые объекты могут содержать изменяемые объекты. В этом случае значения изменяемых объектов может быть изменено, но не ссылка на сам изменяемый объект. Таким случаем является список внутри кортежа:

```python
>>> t = [1, 2, 3, 4]
>>> x = t,
>>> x
([1, 2, 3, 4],)
>>> x[0]
[1, 2, 3, 4]
>>> x[0].append(10)
>>> x
([1, 2, 3, 4, 10],)
>>>
```

###  5.1 Слабые и сильные ссылки на объекты

Объекты Python получают ссылки когда они связываются с именами. Связывание может произойти после присваивания, вызова метода с параметрами или другими способами. Каждый раз когда объект получает ссылку увеличивается счётчик ссылок. Значение счётчика ссылок можно получить функцией `sys.getrefcout()`:

```python
import sys

l = []
m = l

print(sys.getrefcount(l)) # 3
```
В примере три ссылки: `l`, `m` и ссылка из параметра `getrefcount`.

В Python применяется два типа ссылок: слабые и сильные. Если это точно не указано, то при упоминании ссылок речь идет о сильных ссылках, как в приведенном выше примере три сильные ссылки.

Главная особенность сильных ссылок — когда они создаются то счётчик ссылок увеличивается на 1. Сборщик мусора не удалит объект на который есть сильная ссылка, так как он удаляет только объекты счетчик ссылок которых равен 0.

Слабые ссылки не увеличивают счётчик ссылок объекта. Модуль `weakref` предназначен для работы со слабыми ссылками:

```python
import sys
import weakref


class Foo:
    pass


a = Foo()
b = a
print(sys.getrefcount(a)) # 3

c = weakref.ref(a)
print(sys.getrefcount(a)) # 3

print(c()) # <__main__.Foo object at 0x01481F88>
print(type(c)) # <class 'weakref'>
```

Функция `weakref.ref` возвращает объект при вызове которого (как вызов функции `c()`) возвращается объект на который слабая ссылка. Другая функция `weakref.proxy` так же создаёт слабую ссылку и возвращает объект который может использоваться как оригинальный объект без необходимости вызова:

```python
import sys
import weakref


class Foo:
    pass

    def get(self):
        return 23


a = Foo()
b = weakref.proxy(a)
print(sys.getrefcount(a)) # 2

print(b) # <__main__.Foo object at 0x03911F88>
print(b.get()) # 23
```

Когда все сильные ссылки на объект удалены, слабые ссылки тоже ссылку на объект и объект готов для уничтожения сборщиком мусора.

```python
import weakref


class Foo:
    pass


a = Foo()
b = weakref.ref(a)

del a

print(b) # <weakref at 0x03799AF0; dead>
print(b()) # None
```

### 5.2 Иерархия типов

В этом разделе перечислены категории встроенных типов Python.

#### Тип None

The None type is a singleton object that has a single value and this value is accessed through the built-in name None. 

Тип **None** это синглтон который содержит только одно значение и это значение доступно под встроенным именем `None`. Этот тип используется для обозначеия отсутствия значения, например, когда функция не возвращает значения в явном виде:

```python
def print_name(name):
    print(name)


name = print_name("nkem")

print(name) # None
print(type(name)) # <class 'NoneType'>
```

При преобразованию к логическому типу `None` становится `False`:

```python
print(bool(None)) # False
```

#### Тип NotImplemented

Тип **NotImplemented** так же является синглтоном с одним значением. Значение этого объекта доступно под встроенным именем `NotImplemented`. Такой объект используется чтобы делегировать поиск реализации метода интерпретатору вместо генерации исключений `NotImplementedError`:


```python
class Foo:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        if isinstance(other, Foo):
            print('Сравнение экземпляра Foo с другим экземпляром Foo')
            return other.value == self.value

        elif isinstance(other, Bar):
            print('Сравнение экземпляра Foo с экземпляром Bar')
            return other.value == self.value

        print('Невозможно сравнить экземпляр Foo с другим классом')
        return NotImplemented


class Bar:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        if isinstance(other, Bar):
            print('Сравнение экземпляра Bar с другим экземпляром Bar')
            return other.value == self.value

        print('Невозможно сравнить экземпляр Bar с другим классом')
        return NotImplemented
```

Эффект возврата `NotImplemented` наблюдается при попытке сравнения. `a == b` приводят к вызову `a.__eq__(b)`. В примере, классы `Foo` и `Bar` содержат реализацию для сравнения себя с другими объектами:

```python
f = Foo(1)
b = Bar(1)

res = f == b # Сравнение экземпляра Foo с экземпляром Bar
print(res) # True

res = f == f # Сравнение экземпляра Foo с другим экземпляром Foo
print(res) # True

res = b == f # Сравнение экземпляра Bar с другим экземпляром Bar
print(res) # True
```

If b is compared with f then b.__eq__(f) is invoked and the NotImplemented object is returned
because the implementation of __eq__() in Bar only supports comparison with a Bar instances.

Если `b` сравнивается с `f` то вызывается `b.__eq__(f)` и возвращается объект `NotImplemented`, так как реализация в `Bar` поддерживает сравнение только с экземпляром `Bar`. Несмотря на это операция сравнения будет выполнена:

```python
res = b == f
# Сравнение экземпляра Bar с другим экземпляром Bar
# Сравнение экземпляра Foo с экземпляром Bar
print(res) # True
```

Вызов  метода `b.__eq__(f)` возвращает `NotImplemented` заставляю интерпретатор вызывать `__eq__()` у объекта класса `Foo` и так как в этом методе сравнение реализовано, возвращается корректный результат сравнения.

Объект `NotImplmented` преобразовывается к логическому типу как `True`.

```python
print(bool(NotImplemented)) # True
```

#### Тип Ellipsis

Это ещё один синглтон с одним объектом-значением. Значение этого объекта доступно через литерал `...` или встроенное имя `Ellipsis`. Логическое значение этого объекта True:

```python
print(bool(...)) # True
```
Объект `Ellipsis` используется для индексации матриц, подробнее о нем написано в [документации по numpy](https://docs.scipy.org/doc/numpy/user/basics.indexing.html).

#### Числовые типы

Объекты числовых типов неизменяемы, созданное однажды значение не может быть изменено. Числовые типы делятся на несколько категорий.

**Целые числа**

Класс `int` представляет множество  положительных и отрицательных целых чисел. Целые числа не ограничены размером:

```python
print(238**238)
#42200323427409150751742179532592018252808661114071266629718376939092568551075505740268077803623642715001998769421215763628719631633378375087756319383725641630331895773386010866243028159828607385899087848942302738709343403640250275314218243930567432731458807734886574283968918955323573297631562415292893276034393336066052132808455118105272470307339550216091253570417050545677371810192238471803263478546492058686483752405946094606978411379079233793804753705243644236607675749522119768311584522527886912942059070222789851175661909205254663263392466134105108288691503104
```

**Логическое значения**

Тип `bool` представляет значения `True` и `False`.  `bool` является подтипом `int`:

```python
print(type(True).__base__) # <class 'int'>
```

Значения `False` и `True` ведут себя как 0 и 1 соответственно. При конвертации в строку получаются значения "True" и "False":

```python
x = 1
y = True
print(x + y) # 2

a = 1
b = False
print(a + b) # 1

print(b == 0) # True
print(y == 1) # True

print(str(True)) # 'True'
print(str(False)) # 'False'
```

**Числа с плавающей запятой**

Тип `float` представляет числа с плавающей запятой. Точные ограничения этого типа зависят от реализации интерпретатора. В CPython тип `float` соответствует типу `double` в C. 

**Комплексные числа**

Тип `complex` содержит пару числе с типом `float`. 

```python
c = complex(1, 2)
print(c) # (1+2j)
```

Комплексное число можно создать с помощью литерала:

```python
c = 3+5j
print(type(c)) # <class 'complex'>
```

Реальная и мнимая часть комплексного числа доступна как свойства объекта:

```python
c = complex(1, 2)

print(c.real) # 1.0
print(c.imag) # 2.0
```

#### Последовательности

Последовательности это конечные упорядоченные коллекции объектов. Последовательности индексируются целыми числами, в Python допустимо использование отрицательных индексов. Последовательности делятся на две категории: изменяемые и неизменяемые.

##### Неизменяемые последовательности

Неизменяемые последовательности — это коллекции ссылки на объекты в которых не изменяются после создания. В неизменяемой последовательности может быть ссылка на изменяемый объект, в этом случае значение этого изменяемого объекта может манятся, но сама ссылка на этот изменяемый объект навсегда зафиксирована в неизменяемой последовательности.

Например, кортеж (неизменяемая последовательность) содержит список (изменяемая последовательность). Можно изменять элементы входящие в список. Но нельзя поместить в кортеж ссылку на другой список.

```python
t = [1, 2, 3], "obi", "ike"
print(type(t)) # <class 'tuple'>

t[0].append(4) # изменяем список
print(t) # ([1, 2, 3, 4], 'obi', 'ike')

t[0] = [] # попытка изменить ссылку внутри кортежа
# Traceback (most recent call last):
#   File "test.py", line 7, in <module>
#     t[0] = [] # попытка изменить ссылку внутри кортежа
# TypeError: 'tuple' object does not support item assignment
```

Встроенные неизменяемые последовательсти:

* Строки (Strings)
* Байты (Bytes)
* Кортежи (Tuples)

**Strings**

Строки это неизменяемая последовательность символов (точнее Unicode code points). В Python нет отдельного типа для символов, так что символ это просто строка длины 1. Строки в Python могут предствлять все Unicode code points в диапазоне `U+0000 - U+10FFFF`. Для хранения строк используется тип `str`.

```python
print(type('Hello')) # <class 'str'>
```

**Bytes**

Объект типа `bytes` это неизменяемая последовательность 8-битных байт. Каждый байт представлен в виде целого числа от 0 до 255. Литерал вида `b'abc'` и встроенная функция `bytes()` используются для создания объекта Bytes. 

Bytes тесно взаимодействует со строками. Строки внутри представляют собой последовательность байт декодированную с помощью кодировки (например UTF-8). Символы строк могут быть закодированы с помощью разных кодировок в разные последовательности байт.

```python
b = b'abc'
print(b) # b'abc'

print(type(b)) # <class 'bytes'>

# кодирование строки в байты используя кодировку UTF-16
b = bytes('abc', 'utf-16') 
print(b) # b'\xff\xfea\x00b\x00c\x00'


print(b.decode("utf-16")) # 'abc'
print(type(b.decode("utf-16"))) # <class 'str'>

# декодирование строки неудачно, 
# так как символы закодированы в другой кодировке
print(b.decode("utf-8")) 
# Traceback (most recent call last):
#   File "test.py", line 13, in <module>
#     print(b.decode("utf-8")) 
# UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

**Tuple**

3. Tuple: A tuple is a sequence of arbitrary python objects. Tuples of two or more items are
formed by comma-separated lists of expressions. A tuple of one item is formed by affixing
a comma to an expression while an empty tuple is formed by an empty pair of parentheses.
This is illustrated in the following example.
>>> names = "Obi", # tuple of 1
>>> names
('Obi',)
>>> type(names)
<class 'tuple'>
>>> names = () # tuple of 0
>>> names
()
>>> type(names)
<class 'tuple'>
>>> names = "Obi", "Ike", 1 # tuple of 2 or more
>>> names
('Obi', "Ike", 1)
>>> type(names)
<class 'tuple'>


4. Mutable sequences: An immutable sequence type is one whose value can change after it has
created. There are currently two built-in mutable sequence types - byte arrays and lists
1. Byte Arrays: Bytearray objects are mutable arrays of bytes. Byte arrays are created using
the built-in bytearray() constructor. Apart from being mutable and thus unhashable,
byte arrays provide the same interface and functionality as immutable byte objects.
Bytearrays are very useful when the efficiency offered by their mutability is required.
For example, when receiving an unknown amount of data over a network, byte arrays
are more efficient because the array can be extended as more data is received without
having to allocate new objects as would be the case if the immutable byte type was used.
2. Lists: Lists are a sequence of arbitrary Python objects. Lists are formed by placing a
comma-separated list of expressions in square brackets. The empty list is formed with
the empty square bracket, []. A list can be created from any iterable by passing such
iterable to the list method. The list data structure is one of the most widely used data
type in python.
Sequence types have some operations that are common to all sequence types. These are described
in the following table; x is an object, s and t are sequences and n, i, j, k are integers.
Objects 201 39
Operation Result
x in s True if an item of s is equal to x, else False
x not in s False if an item of s is equal to x, else True
s + t the concatenation of s and t
s * n or n * s n shallow copies of s concatenated
s[i] ith item of s, origin 0
s[i:j] slice of s from i to j
s[i:j:k] slice of s from i to j with step k
len(s) length of s
min(s) smallest item of s
max(s) largest item of s
s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and
before index j)
s.count(x) total number of occurrences of x in s
Note
1. Values of n that are less than 0 are treated as 0 and this yields an empty sequence of the same
type as s such as below:
>>> x = "obi"
>>> x*-2
''
2. Copies made from using the * operation are shallow copies; any nested structures are not
copied. This can result in some confusion when trying to create copies of a structure such as
a nested list.
>>> lists = [[]] * 3 # shallow copy
>>> lists
[[], [], []] # all three copies reference the same list
>>> lists[0].append(3)
>>> lists
[[3], [3], [3]]
To avoid shallow copies when dealing with nested lists, the following method can be adopted
Objects 201 40
```python
>>> lists = [[] for i in range(3)]
>>> lists[0].append(3)
>>> lists[1].append(5)
>>> lists[2].append(7)
>>> lists
[[3], [5], [7]]
```
3. When i or j is negative, the index is relative to the end of the string thus len(s) + i or len(s)
+ j is substituted for the negative value of i or j.
4. Concatenating immutable sequences such as strings always results in a new object for
example:
>>> name = "Obi"
>>> id(name)
4330660336
>>> name += "Obi" + " Ike-Nwosu"
>>> id(name)
4330641208
Python defines the interfaces (thats the closest word that can be used) - Sequences and MutableSequences in the collections library and these define all the methods a type must implement to be
considered a mutable or immutable sequence; when abstract base classes are discussed, this concept
will become much clearer.
