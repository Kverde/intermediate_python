% Intermediate Python
% Obi Ike-Nwosu
% leanpub.com, 2016

# Intermediate Python

Перевод книги [Intermediate Python](https://leanpub.com/intermediatepython) Obi Ike-Nwosu. Перевод выполнен с сокращениями, часть текста и примеры изменены.

## 1. Благодарности

Благодарю всех кто помогал при написании и корректировке книги. 

## 2. Введение

Эта книга рассчитана на средний уровень знакомства с Python. В качестве интерпретатора подразумевается [CPython](https://www.python.org/). [Документация](https://docs.python.org/3/reference/index.html) последней стабильной версии.

## 3. Очень короткий учебник

Этот короткий учебник раскрывает основные концепции и возможности языка программирования Python.

### 3.1 Использование Python

Python установлен по умолчанию на Unix-системах. Для проверки установлен ли Python, откройте командную строку и введите `python`. Если Python не установлен то откройте [сайт Python](https://www.python.org/) и следуйте инструкциям для вашей платформы.

Если после установки Python не запускается из командной строки, проверьте добавлен ли путь к интерпретатору в системные пути.

Запуск интерпретатора командой `python` начинает интерактивную сессию [REPL](https://ru.wikipedia.org/wiki/REPL). Основная подсказка `>>>` предлагает ввести команду, вторичная подсказка `...` сигнализирует о продолжении предыдущей инструкции:

```python
>>> def hello():
...     print("Hello world")
...
>>>
```

Пользователь вводит инструкции python и немедленно получает ответ. В режиме REPL Python может использоваться как продвинутый калькулятор:

```python
Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:21:23) [MSC v.1916 32 bit (In
tel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> a = 3
>>> b = 3
>>> a * b + 5
14
>>>
```

Введите Ctrl+Z для завершения сессии интерпритатора.

### 3.2 Операторы Python, строки и отступы

Программа на Python состоит из логических строк ограниченных токеном **NEWLINE**. Каждая логическая строка эквивалентна простому оператору. Составные операторы формируются из нескольких логических строк.

Логическая строка создаётся из одной или нескольких физических строк используя явные или не явные правила объединения строк. Физическая строка — это последовательность символов завершающаяся символами перевода строки (end-of-line sequence). Python неявно рассматривает физические строки как логические, устраняя необходимость в точке с запятой для разделения выражений. Однако точка с запятой может использоваться для разделения одной физической строки на несколько логических:

```Python
>>> i = 5; print i;
5
```

Несколько физических строк в явном виде объединяются в одну логическую символом "\\":

```Python
>>> name = "Obi Ike-Nwosu"
>>> cleaned_name = name.replace("-", " "). \
... replace(" ", "")
>>> cleaned_name
'ObiIkeNwosu'
>>>
```

Физические строки соединяются неявно, без использования символа продолжения строки ("\\"), когда выражение находится в тройных строковых кавычках, заключено в скобки `(...)`, `[...]`, или `{...}`.

Python содержит два типа операторов.

Простые операторы занимающие одиночные логические строки. Они включают в себя присваивание, **yield** и др. Общий синтаксис простых операторов:

```
simple_stmt ::= expression_stmt
            | assert_stmt
            | assignment_stmt
            | augmented_assignment_stmt
            | pass_stmt
            | del_stmt
            | return_stmt
            | yield_stmt
            | raise_stmt
            | break_stmt
            | continue_stmt
            | import_stmt
            | global_stmt
            | nonlocal_stmt
```

Составные операторы занимающие несколько логических строк. Они включают в себя выражения циклов **while** и **for**. Общий синтаксис составных операторов:

```
compound_stmt ::= if_stmt
              | while_stmt
              | for_stmt
              | try_stmt
              | with_stmt
              | funcdef
              | classdef

suite ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT

statement ::= stmt_list NEWLINE | compound_stmt

stmt_list ::= simple_stmt (";" simple_stmt)* [";"]
```

Составные операторы содержат одно или несколько предложений (clause). Предложение состоит из заголовка (header) и тела (suite). Заголовки предложений для одного составного оператора имеют одинаковый отступ и начинаются с уникального идентификатора (**while**, **if** и т.д.) и с двоеточия. Составной оператор **if** определяется так:

```
if_stmt ::=  "if" expression ":" suite
             ( "elif" expression ":" suite )*
             ["else" ":" suite]
```

Выполнение тела предложения контролируется заголовком:

```Python
>>> num = 6
# оператор if является составным оператором
    # Заголовок предложения контролирует выполнение следующего блока с отступом
>>> if num % 2 == 0:
        # блок тела с отступом
...     print("The number {} is even".format(num))
...
The number 6 is even
>>>
```

Тело (suite) может быть набором из одного или нескольких операторов который следуют за двоеточием заголовка, в этом случае, операторы разделяются точкой с запятой:

```Python
>>> x = 1
>>> y = 2
>>> z = 3
>>> if x < y < z: print(x); print(y); print(z)
...
1
2
3
```

Но обычно тело (suite) записывается со следующей после заголовка строки в виде одного или нескольких операторов с отступом:

```Python
>>> x = 1
>>> y = 2
>>> z = 3
>>> if x < y < z:
...    print(x)
...    print(y);
...    print(z)
...
1
2
3
```

Отступы используются для обозначения блоков кода таких как тела функций, условий, циклов и классов. Ведущий пробел в начале логической строки используется для вычисления отступа для этой строки, который, в свою очередь, используется для определения группировки оператора. Отступ используемый в теле блока всегда должен совпадать с отступом первого оператора в блоке.

### 3. Строки

Строки в Python обрамляются двойными "..." или одинарными '...' кавычками. Спецсимволы указываются внутри строки с экранированием:

```python
# кавычка используется как апостроф, поэтому мы экранируем её чтобы 
# предотвратить завершение строки
>>> name = 'men\'s'
>>> name
"men's"
>>>
```

Для того чтобы отключить обработку спецсимволов в строке, добавьте перед строкой символ **r**:

```python
>>> print('C:\some\name') # здесь \n означает перевод строки!
C:\some
ame
>>> print(r'C:\some\name') # добавлен r перед кавычкой
C:\some\name
```

Многострочные строковые литералы задаются тройными кавычками. Перевод строки автоматически добавляется при достижении конца строки:

```python
>>> para = """hello world I am putting together a
... book for beginners to get to the next level in python"""
# Обратите внимание на символ перевод строки
>>> para
'hello world I am putting together a \nbook for beginners to get to the next level in python'
# При выводе текст разделяется на несколько срок
>>> print(para)
hello world I am putting together a
book for beginners to get to the next level in python
>>>

Чтобы перевод строки не добавлялся используйте символ **\** в конце строки:

​```python
>>> para = """hello world I am putting together a \
... book for beginners to get to the next level in python"""
>>> para
'hello world I am putting together a book for beginners to get to the next level in python'
>>> print(para)
hello world I am putting together a book for beginners to get to the next level in python
>>>
```

Строки неизменяемые, один раз созданная строка не может быть изменена. Для символов отдельного типа нет, они являются строками длинной в 1 символ. Строки являются одним из типов последовательностей, поэтому поддерживают все операции с последовательностями, за исключением присваивания по индексу из-за неизменяемости. Обращение к отдельному символу происходит по индексу:

```python
>>> name = 'obiesie'
>>> name[1]
'b'
>>>
```

Строки соединяются оператором **+**:

```python
>>> name = 'obiesie'
>>> surname = " Ike-Nwosu"
>>> full_name = name + surname
>>> full_name
'obiesie Ike-Nwosu'
>>>
```

Написанные рядом строковые литералы соединяются автоматически:

```python
>>> 'Py' 'thon'
'Python'
>>>
```

Встроенная функция **len** возвращает длину строки:

```python
>>> name = "obi"
>>> len(name)
3
>>>
```

### 3.4 Управляющие конструкции

#### if-else и if-elif-else

Оператор **if** применяется для условного выполнения блока кода:

```python
>>> name = "obi"
>>> if name == "obi":
...     print("Hello Obi")
...
Hello Obi
>>>
```

За оператором **if** следует ноль или больше операторов **elif** и не обязательный оператор **else**. Если не один из операторов **if** или **elif** не был выполнен, то выполняется блок **else**:

```python
>>> if name == "obi":
...     print("Hello Obi")
... elif name == "chuks":
...     print("Hello chuks")
... else:
...     print("Hello Stranger")
Hello Stranger
>>>
```

#### for и range

В Python два вида циклов: **while** и **for**.

Оператор **for** используется для перебора последовательностей (list, set, tuple и т.д.). В общем случае, цикл **for** используется для перебора любых объектов реализующих протокол итератора Python (python iterator protocol). Подробнее это будет описано в следующих главах.

Пример использования цикла **for**:

```python
>>> names = ["Joe", "Obi", "Chris", "Nkem"]
>>> for name in names:
...     print(name)
...
Joe
Obi
Chris
Nkem
>>>
```

Большинство языков программирования использует синтаксис похожий на этот для перебора последовательности чисел:

```
for(int x = 10; x < 20; x = x+1) {
// do something here
}
```

В Python используется конструкция **range()** для генерации арифметической прогрессии целых чисел:

```python
>>> for i in range(10, 20):
...     print i
...
10
11
12
13
14
15
16
17
18
19
```

Функция range(start, stop, step) допускает три аргумента. Значение параметра **stop** не входит в возвращаемую последовательность.

#### while

Оператор **while** выполняет блок кода пока условное выражение вычисляется в **True**:

```python
>>> counter = 10
>>> while counter > 0: # условное выражение 'counter > 0'
...     print(counter)
...     counter = counter - 1
...
10
9
8
7
6
5
4
3
2
1
```

#### break и continue

Команда **break** завершает выполнение цикла, после **break** происходит немедленный выход из цикла.

```python
>>> for i in range(10):
...     if i == 5:
...         break
...     else:
...         print(i)
...
0
1
2
3
4
```

Команда **continue** принудительно запускает следующую итерацию цикла. Все команды внутри цикла после **continue** игнорируются.

```python
>>> for i in range(10):
        # если i равно 5 то начинаем новую итерацию цикла, без выполнения остальных команд
...     if i == 5:
...         continue
...     print("The value is " + str(i))
...
The value is 0
The value is 1
The value is 2
The value is 3
The value is 4
# no printed value for i == 5
The value is 6
The value is 7
The value is 8
The value is 9
```

В примере выше, значение 5 не напечатано, из-за условия и команды **continue**. Все остальные значения напечатаны.

#### циклы и else 

В Python ключевое слово **else** применяется вместе с операторами цикла. Блок после **else** выполняется если цикл не был завершён оператором **break**.

```python
# loop exits normally
>>> for i in range(10):
...     print(i)
... else:
...     print("I am in quirky else loop")
...
0
1
2
3
4
5
6
7
8
9
I am in quirky else loop
```

Если цикл завершён оператором **break**, то блок **else** пропускается:

```python
>>> for i in range(10):
...     if i == 5:
...        break
...     print(i)
... else:
...     print("I am in quirky else loop")
...
0
1
2
3
4
```

#### Enumerate

Иногда нужно перебрать коллекцию, поучая одновременно индекс и значение элементов. Можно использовать такой подход:

```python
>>> names = ["Joe", "Obi", "Chris", "Jamie"]
>>> name_count = len(names)
>>> index = 0
>>> while index < name_count:
...   print("{}. {}".format(index, names[index]))
...   index = index + 1
...
0. Joe
1. Obi
2. Chris
3. Jamie
```

В Python есть более эффективное решение с функцией **enumerate**:

```python
>>> for index, name in enumerate(names):
...     print("{}. {}".format(index, name))
...
0. Joe
1. Obi
2. Chris
3. Jamie
>>>
```
### 3.5 Функции

Именованные функции определяются ключевым словом **def**, за которым следует название функции и список параметров в скобках. Ключевое слово **return** используется для возвращения значения функции:

```python
def full_name(first_name, last_name):
    return " ".join((first_name, last_name))
```

Для вызова функции используется её имя, параметры передаются в скобках:

```python
full_name("Obi", "Ike-Nwosu")
```

Функции могут вернуть несколько значений в виде кортежа. В следующим примере функция возвращает частное и остаток от деления:

```python
>>> def divide(a, b):
...     return divmod(q, r)
...
>>> divide(7, 2)
(3, 1)
>>>
```

Функция без **return** всегда возвращает **None**:

```python
>>> def print_name(first_name, last_name):
...     print(" ".join((first_name, last_name)))
...
>>> print_name("Obi", "Ike-Nwosu")
Obi Ike-Nwosu
>>> x = print_name("Obi", "Ike-Nwosu")
Obi Ike-Nwosu
>>> x
>>> type(x)
<type 'NoneType'>
>>>
```

Ключевое слово **return** может использоваться без значения чтобы прервать выполнение функции:

```python
>>> def dont_return_value():
...     print("How to use return keyword without a value")
...     return
...
>>> dont_return_value()
```

Выражение **lambda** позволяет объявить функцию без имени. Такая функция состоит всего из одного выражения которое и является значением функции. Поэтому не требуется использовать **return**.


```python
>>> square_of_number = lambda x: x**2
>>> square_of_number
<function <lambda> at 0x101a07158>
>>> square_of_number(2)
4
>>>
```

Функция созданная через **lambda** эквивалентна именованной функции определённой через **def**.

### 3.6 Структуры данных

Python содержит встроенные типы данных: списки, кортежи, словари.

#### Списки

Списки создаются используя квадратные скобки или функцию `list()`:

```python
my_list1 = [] # Пустой список
my_list2 = list() # Пустой список
```

Список сохраняет порядок элементов с которым создаётся или в котором элементы добавляются. Списки являются последовательностями и поддерживают доступ по индексу, другие свойства последовательностей будут описаны в следующих главах. 

Первый элемент списка находится под индексом 0, последний — на единицу меньше длины списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name[0]
'obi'
>>> name[1]
'ike'
>>> name[2]
'nwosu'
```

Метод `append()` добавляет элемент в список.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name.append("nkem")
>>> names
["obi", "ike", "nwosu", "nkem"]
```

Метод `insert()` добавляет элемент в любое место списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name.insert(1, "nkem")
>>> names
["obi", "nkem", "ike", "nwosu"]
```

Оператор `+` позволяет объединить два и более списка.

```python
>>> name = ["obi", "ike", "nwosu"]
>>> name1 = ["James"]
>>> name + name1
["obi", "ike", "nwosu", "James"]
```

Для просмотра всех методов списка запустите команду `help(list)`.

#### Кортежи

Кортеж тоже является последовательностью и создается элементами разделёнными запятыми:

```python
>>> companies = "Google", "Microsoft", "Tesla"
>>> companies
('Google', 'Microsoft', 'Tesla')
```

При определении непустого кортежа скобки не обязательны, но они становятся обязательными когда кортеж является частью большего выражения. Пустой кортеж создаётся пустой парой скобок:

```python
>>> companies = ()
>>> type(companies)
<class 'tuple'>
```
При определении кортежа с одним элементом запятая за ним обязательна.

```python
>>> company = "Google",
>>> type(company)
<class 'tuple'>

>>> company = ("Google",)
>>> type(company)
<class 'tuple'>
```

Пропуск запятой означает что задано обычное значение, не кортеж.

```python
>>> company = ("Google")
>>> company
'Google'

>>> type(company)
<class 'str'>
```

Кортежи индексируются как списки, но неизменямы.

```python
>>> companies = ("Google", "Microsoft", "Palantir")
>>> companies[0]
'Google'
>>> companies[0] = "Boeing"
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

В тоже время, если элементом кортежа является изменяемые объект, такой как список, то он может быть изменен.

```python
>>> companies = (["lockheedMartin", "Boeing"], ["Google", "Microsoft"])
>>> companies
(['lockheedMartin', 'Boeing'], ['Google', 'Microsoft'])
>>> companies[0].append("SpaceX")
>>> companies
(['lockheedMartin', 'Boeing', 'SpaceX'], ['Google', 'Microsoft'])
```

#### Множества

Множества это неупорядоченные коллекции объектов не содержащие дубликатов. Пустое множество создаётся функцией `set()` или круглыми скобками `{}`.  Множества неупорядоченны поэтому к элементам множества нельзя обратится по индексу. Множества, за исключением frozen set, изменяемы.

```python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> basket_set = set()
>>> basket_set
set()
>>> basket_set.update(basket)
>>> basket_set
{'pear', 'orange', 'apple', 'banana'}
>>> basket_set.add("clementine")
>>> basket_set
{'pear', 'orange', 'apple', 'banana', 'clementine'}
>>> basket_set.remove("apple")
>>> basket_set
{'pear', 'orange', 'banana', 'clementine'}
```

#### Словари

Словарь в Python похож на ассоциативный массив или хеш-таблицу в других языках. Словари индексируются по неизменяемому ключу. Для создания словаря используются фигурные скобки `{}` или функция`dict()`. Словарь — неупорядоченное множество пар ключ-значение в которых ключ уникален. Пример инициализации словаря:

```python
ages = {"obi": 24,
"nkem": 23,
"Chris": 23
}
```

Основные операции словаря это сохранение значения по ключу и доступ к значению по ключу. Доступ к значению осуществляется через квадратные скобки:

```python
>>> ages["obi"]
24
```

Словари изменяемы, значения связанные с ключами могут менятся, добавлятся и удалятся.

Структуры данных Python не ограничиваются приведёнными в этом разделе. Например, модуль `collections` содержит очереди, деки и другие коллекции. В то же время структуры приведённые в этом разделе используются в большинстве приложений на Python.

Используйте функцию help с параметром в виде названия типа данных для детального изучения типа.

```python
help(list)
help(tuple)
help(set)
help(dict)
```

### 3.7 Классы

Выражение `class` используется для определения новых типов в Python:

```python
class Account:
    # классовая переменная общая для всех экземпляров классов
    num_accounts = 0

    def __init__(self, name, balance):
    # переменные экзепляра
    self.name = name
    self.balance = balance
    
    # изменение классовой переменной 
    Account.num_accounts += 1

    def deposit(self, amt):
        self.balance = self.balance + amt

    def withdraw(self, amt):
        self.balance = self.balance - amt

    def inquiry(self):
        return "Name={}, balance={}".format(self.name, self.balance)

    @classmethod
    def from_dict(cls, params):
        params_dict = json.loads(params)
        return cls(params_dict.get("name"), params_dict.get("balance"))
```

Классы в Python, как в других языках, могут содержать классовые пеменные, переменные объекта, классовые методы, статичные методы и методы объекта. 

При определении класса, имя родителського класса указывается в скобках после названия класса.

```python
class dog(animal):

```

Метод `__init__` похож на конструктор в других языках программирования. В этом методе инициализируются переменные объекта. Для создания объекта класса `Account` нужно передать аргументы указанные в `__init__` за исключением `self`:

```python
>>> acct = Account("obie", 10000000)
```

Методы обявленные с аргументом `self` являются методами объекта. Аргумент `self` является ссылкой на объект. Методы вызываются через точку:

```python
>>> acct = Account("obie", 10000000)
>>> account.inquiry()
Name=obie, balance=10000000
```

Встроенная функция `dir` предназачена для исследования объектов и печатает все методы, переменные и атрибуты объекта который в неё передан.

### 3.8 Модули

С ростом размера и сложности кода он всё больше нуждается в структуризации. Python позволяет разделить кода на несколько файлов. Каждый файл назвывается модулем имеет расширений `.py`. Для обращения к определениям из файла его необходимо имортировать командой `import`. 

```python
>>> import Account
>>> acct = Account.Account("obie", 10000000)
```

Команда `import` требует имя модуля без расширения `.py`.  При иморте создается пространство имён с именем модуля (в примере `Account`). Доступ к определням из пространства имён осуществляется через точку (`.`).

Ключевое слово `as` задаёт название пространство имён отличное от названия модуля:

```python
>>> import Account as acct
>>> account = acct.Account("obie". 10000000)
```

Возможнен иморт отдельных определений из модуля вместо всего модуля:

```python
>>> from Account import Account
>>> account = Account("obie", 10000000)
```

Возможно импортрровать все опредления из модуля:

>>> from Account import *

Такой способ не рекуомендуется, так как приводит к конфликтам разных пространств имён: импортированные имена из одного модуля перезаписываются импортом из другого.

Модули это обычные объекты Python, их можно исследовать функцией `dir`. Модули могут быть сгруппированы в пакеты. Пакеты и модули детальнее описаны в следующих главах.

### 3.9 Исключения

Python поддерживает исключения и перехват исключений. Например, при делении на ноль интерпритатор выбросит исключение `ZeroDivisionError`.

```python
>>> 2/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>>
```
Во время выполнения программы, исключение генерируется когда происходит ошибка. Если исключение не обработано, то на экран будет выведен стек вызовов. В обычном случае необработанное исключение остановит выполнение программы.

Исключения перехватываются командой `try...catch`:

```python
>>> try:
...     2/0
... except ZeroDivisionError as e:
...     print("Attempting to divide by 0. Not allowed")
...
Attempting to divide by 0. Not allowed
>>>
```
Исключения бывают разных типов. В примере выше обрабатывается исключение `ZeroDivisionError` и если в защищенном коде возникнет другое исключение, то работа программы остановится.

Для перехвата любого исключения тип исключения не указывается

```python
>>> try:
...     2/0
... except:
...     print("Attempting to divide by 0. Not allowed")
...
Attempting to divide by 0. Not allowed
>>>
```
Такая конструкция не рекомендуется, так как невозможно сказать какой тип возникшего исключения.

Для объявления пользовательского типа исключения создаётся класс наследуемый от `Excption`. Пользовательские исключения перехватываются тем же способом что и стандартные.

### 3.10 Ввод и вывод

Python поддерживает операции ввода и вывода из разных источников. Пример чтения файла:

```python
f = open("afile.txt")
line = f.readline()
while line:
    print(line)
    line = f.readline()
```

Метод `open` возвращает объект типа `file` или генерирует исключение если файл не сущетвует. Объект типа `file` поддерживает методы такие как чтение всего файла в строку (`read`) или чтение одной строки файла (`readline`). Python поддерживает синтаксический сахар для перебора всех строк файла:

```python
for line in open("afile.txt"):
    print(line)
```

Пример записи в файл:

```python
f = open("out.txt", "w")
contents = ["I", "love", "python"]
for content in contents:
    f.write(content)
f.close()
```

Python так же поддерживает запись в стандартный поток вывода и чтение из стандартного потока ввода.

```python
name = input('What is your name? ')
print(f'Hello, {name}')
```

### 3.11 Документация

Интерпретатор Python содержит много встроенной документации. Для получения документации используйте команду `help`, в параметре передаётся название класса или онструкции языка.

```python
help('try')
help(list)
```

## 4.  Intermezzo: Глоссарий

В этой книге используются термины и эзотерический функции Python понимание которые является условием глубокого понимания Python. Ниже даётся объяснение этих терминов и функций.

### 4.1 Имена и связывание

В Python, на объекты ссылаются через имена. Имена аналогичны переменным в C++ или Java.

```
>>> x = 5
```

В примере выше, `x` &mdash; имя которое ссылается на объект `5`. Процесс присваивания ссылки на `5` в `x` называется связыванием. Связывание приводит к тому что имя ассоциируется с объектом. 

Связывание происходит в разных ситуациях: при присваивании и при вызове методов, когда параметры связываются с аргументами.

Важная особенность: **имена являются только ссылками без связанного с ними типа; имена ссылаются на объекты которые имеют тип**.

Присваивание создаёт новое имя в самой внутренней области видимости программы: если присваивание выполняется в коде модуля &mdash; имя добавляется в глобальные переменные модуля, если в коде функции &mdash; в локальные переменные функции.

### 4.2 Блоки кода

Блок кода это часть программы запускаемая как одно целое. Модули, функции и класс являются примерами блоков кода. Команды вводимые в REPL скрипты запущенные с опцией `-c` тоже блоки кода. Блок кода содержит пространства имён связанные с ним. Например, блок кода модуль имеет доступ к глобальному пространству имён, а блок кода функция имеет доступ к локальному и глобальному пространству имён.

### 4.3 Пространства имён

Пространство имён — контекст в котором данное множество имён связано с объектами. Сейчас пространства имён реализованы в виде словаря. Например, пространство имён встроенных функций реализуется словарём `__builtins__.__dict__`.

Интерпретатору доступны несколько пространств имён, включая глобальное пространство имён, пространство имён встроенных функций и локальное пространство имён. Эти пространства имён создаются в разное время и имеют разное время жизни. 

Например, локальное пространство имён создаётся при вызове функции и уничтожается при выходе из функции. Глобальное пространство имён создаётся в начале запуска модуля и все имена определённые в нём доступны для всего модуля. Пространство имён встроенных функций создаётся при запуске интерпретатора и содержит все встроенные имена. Эти три основные пространства имён доступные интерпретатору.


### 4.4 Области видимости

Область видимости это часть программы в которой множество имён (пространств имён) видимы и достыпны напрямую. Прямой доступ важная характеристика области видимости и будет обяснена при разговоре о классах. В простом смысле, это означает что имя может использовать как есть, без использования точки для доступа к имени, как например `SomeClassOrModule.name`. Во время выполнения следующие области видимости могут быть доступны

1. Inner most scope with local names
2. The scope of enclosing functions if any (this is applicable for nested functions)
3. The current module’s globals scope
4. The scope containing the builtin name-space.

1. Самая внутренняя область видимости с локальными именами.
2. Область видимости внешней функции если она есть (для вложенных функций)
3. Глобальная область видимости текущего модуля
4. Пространство имён встроенных функций

При использовании имени интерпретатор ищет в пространствах имён областей видимости в порядке указнном выше и если имя не найдено генерирует исключние.

Python supports static scoping also known as lexical scoping; this means that the visibility of a set of name bindings can be inferred by only inspecting the program text.

Python поддерживает статическое пространство имён (static scoping,  lexical scoping). Это означает что видимость множества свяазанных имён может быть выведено только просмотром текста программы. 

#### Примечание

Python has a quirky scoping rule that prevents a reference to an object in the global scope from being modified in a local scope; such an attempt will throw an UnboundLocalError exception. 

Python содержин правила предотвращающие изменение имени в глобальной области видимости из локальной области области видимости. Попытка сделать это приведёт к исключению `UnboundLocalError`.

```python
>>> a = 1
>>> def inc_a(): a += 2
...
>>> inc_a()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 1, in inc_a
UnboundLocalError: local variable 'a' referenced before assignment
```

Для изменения объекта из глобальной области видимости в локальной облести видимости применяется ключевое слово `global`. Оно должно использоваться до того как происходит изменение объекта.

```python
>>> a = 1
>>> def inc_a():
...     global a
...     a += 1
...
>>> inc_a()
>>> a
2
```

Ключевое слово `nonlocal` используется при необходимости изменитю привязку переменной во внешней не глобальной области видимости из внетренней области видимости. Это полезно во вложенных функциях (замыканиях). Пример использования `nonlocal` при определении объектов-счётчиков: 

```python
>>> def make_counter():
...     count = 0
...     def counter():
...         nonlocal count # nonlocal captures the count binding from enclosing scope not global scope
...         count += 1
...         return count
...     return counter
...
>>> counter_1 = make_counter()
>>> counter_2 = make_counter()
>>> counter_1()
1
>>> counter_1()
2
>>> counter_2()
1
>>> counter_2()
2
```

### 4.5 eval()

Встроенная функция `eval` запускает выражение Python переданное в виде строки или объекта типа `code`. Сигнатура функции:

```python
eval(expression, globals=None, locals=None)
```

При вызове `eval` возвращает результат выражения:

```python
>>> eval("2 + 1") # note the expression is in a string
3
```

Аргумент `globals` должен быть словарём, а `locals` может быть любым отображением. Если `globals` не задан то вместо него используется текущее глобальное пространство имён. Это означает что у кода будет доступ ко всем именам текущего модуля.

```python
def g():
    return 4

print(eval('2 + 2 + g()')) # 8
```

Вместо строки в `eval` можно передать объект типа `code` полученный функцией `compile`.  `eval` и `exec` используется для запуска произвольного Python кода, например, в онлайн интерпретаторах Python.

### 4.6 exec()

`exec` похож на `eval`, он запускает строку (или объект типа `code`) с набором команд Python. Сигнатура `exec`:

```python
exec(object[, globals[, locals]])
```

Пример использования `exec` используя строку и текущее пространство имён:

```python
Python 3.4.2 (v3.4.2:ab2c023a9432, Oct 5 2014, 20:42:22)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.

>>> cont = open('acct.py', 'r').read()

>>> cont
'class Account:\n """base class for representing user accounts"""\n num_accounts = 0\n\n de\
f __init__(self, name, balance):\n self.name = name \n self.balance = balance \n \
Account.num_accounts += 1\n\n def del_account(self):\n Account.num_accounts -= 1\n\n \
def __getattr__(self, name):\n """handle attribute reference for non-existent attribute"""\n \
return "Hey I dont see any attribute called {}".format(name)\n\n def deposit(self, amt):\n\
self.balance = self.balance + amt \n\n def withdraw(self, amt):\n self.balance = s\
elf.balance - amt \n\n def inquiry(self):\n return "Name={}, balance={}".format(self.name,\
self.balance) \n\n'

>>> exec(cont)
# запускаем содержимое файла используя пространство имён по умочанию
>>> Account # теперь мы можем ссылаться на класс Account
<class '__main__.Account'>
>>>
```

Если необязательные аргументы пропущены когда запускается в текущей области видимости. Если задан только `global` то они используется для глобальных и локальных переменных. 

Если словарь переданный в `global` не содержит  ключа `__builtins__` то под этим ключом будет добавлена ссылка на пространство имён встроенных функций. Вставив под ключом `__builtins__` свой словарь можно добиться запрета или ограничения стандартных функций.
